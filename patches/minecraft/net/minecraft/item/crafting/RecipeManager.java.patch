--- a/net/minecraft/item/crafting/RecipeManager.java
+++ b/net/minecraft/item/crafting/RecipeManager.java
@@ -1,24 +_,31 @@
 package net.minecraft.item.crafting;
 
-import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.Maps;
-import com.google.common.collect.ImmutableMap.Builder;
-import com.google.gson.Gson;
-import com.google.gson.GsonBuilder;
-import com.google.gson.JsonElement;
-import com.google.gson.JsonObject;
-import com.google.gson.JsonParseException;
-import com.google.gson.JsonSyntaxException;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Comparator;
+import java.util.HashMap;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
 import java.util.Objects;
 import java.util.Optional;
-import java.util.Map.Entry;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Maps;
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParseException;
+import com.google.gson.JsonSyntaxException;
+
+import it.unimi.dsi.fastutil.objects.Object2ObjectLinkedOpenHashMap;
 import net.minecraft.client.resources.JsonReloadListener;
 import net.minecraft.inventory.IInventory;
 import net.minecraft.item.ItemStack;
@@ -32,13 +_,11 @@
 import net.minecraft.world.World;
 import net.minecraftforge.api.distmarker.Dist;
 import net.minecraftforge.api.distmarker.OnlyIn;
-import org.apache.logging.log4j.LogManager;
-import org.apache.logging.log4j.Logger;
 
 public class RecipeManager extends JsonReloadListener {
    private static final Gson GSON = (new GsonBuilder()).setPrettyPrinting().disableHtmlEscaping().create();
    private static final Logger LOGGER = LogManager.getLogger();
-   private Map<IRecipeType<?>, Map<ResourceLocation, IRecipe<?>>> recipes = ImmutableMap.of();
+   public Map<IRecipeType<?>, Map<ResourceLocation, IRecipe<?>>> recipes = ImmutableMap.of();
    private boolean hasErrors;
 
    public RecipeManager() {
@@ -47,15 +_,32 @@
 
    protected void apply(Map<ResourceLocation, JsonElement> p_212853_1_, IResourceManager p_212853_2_, IProfiler p_212853_3_) {
       this.hasErrors = false;
-      Map<IRecipeType<?>, Builder<ResourceLocation, IRecipe<?>>> map = Maps.newHashMap();
+      //Map<IRecipeType<?>, ImmutableMap.Builder<ResourceLocation, IRecipe<?>>> map = Maps.newHashMap();
+      // CraftBukkit start - SPIGOT-5667 make sure all types are populated and mutable
+      Map<IRecipeType<?>, Object2ObjectLinkedOpenHashMap<ResourceLocation, IRecipe<?>>> map = Maps.newHashMap();
+      for (IRecipeType<?> recipeType : Registry.RECIPE_TYPE) {
+         map.put(recipeType, new Object2ObjectLinkedOpenHashMap<>());
+      }
+      // CraftBukkit end
 
       for(Entry<ResourceLocation, JsonElement> entry : p_212853_1_.entrySet()) {
          ResourceLocation resourcelocation = entry.getKey();
+         if (resourcelocation.getPath().startsWith("_")) continue; //Forge: filter anything beginning with "_" as it's used for metadata.
 
          try {
+            if (entry.getValue().isJsonObject() && !net.minecraftforge.common.crafting.CraftingHelper.processConditions(entry.getValue().getAsJsonObject(), "conditions")) {
+               LOGGER.debug("Skipping loading recipe {} as it's conditions were not met", resourcelocation);
+               continue;
+            }
             IRecipe<?> irecipe = fromJson(resourcelocation, JSONUtils.convertToJsonObject(entry.getValue(), "top element"));
+            if (irecipe == null) {
+               LOGGER.info("Skipping loading recipe {} as it's serializer returned null", resourcelocation);
+               continue;
+            }
+            // CraftBukkit start
             map.computeIfAbsent(irecipe.getType(), (p_223391_0_) -> {
-               return ImmutableMap.builder();
+               return new Object2ObjectLinkedOpenHashMap<>();
+               // CraftBukkit end
             }).put(resourcelocation, irecipe);
          } catch (IllegalArgumentException | JsonParseException jsonparseexception) {
             LOGGER.error("Parsing error loading recipe {}", resourcelocation, jsonparseexception);
@@ -63,15 +_,61 @@
       }
 
       this.recipes = map.entrySet().stream().collect(ImmutableMap.toImmutableMap(Entry::getKey, (p_223400_0_) -> {
-         return p_223400_0_.getValue().build();
+         return p_223400_0_.getValue(); // CraftBukkit
       }));
-      LOGGER.info("Loaded {} recipes", (int)map.size());
-   }
+
+      // CraftBukkit start - SPIGOT-5667 make sure all types are populated and mutable
+      Map<IRecipeType<?>, Object2ObjectLinkedOpenHashMap<ResourceLocation, IRecipe<?>>> map1 = Maps.newHashMap();
+      for (IRecipeType<?> recipeType : Registry.RECIPE_TYPE) {
+         map1.put(recipeType, new Object2ObjectLinkedOpenHashMap<>());
+      }
+      // CraftBukkit end
+      Iterator iterator = p_212853_1_.entrySet().iterator();
+
+      while (iterator.hasNext()) {
+         Entry<ResourceLocation, JsonElement> entry = (Entry) iterator.next();
+         ResourceLocation minecraftkey = entry.getKey();
+
+         try {
+            if (entry.getValue().isJsonObject() && !net.minecraftforge.common.crafting.CraftingHelper.processConditions(entry.getValue().getAsJsonObject(), "conditions")) {
+               LOGGER.debug("Skipping loading recipe {} as it's serializer returned null", minecraftkey);
+               continue;
+            }
+            IRecipe<?> irecipe = fromJson(minecraftkey, JSONUtils.convertToJsonObject(entry.getValue(), "top element"));
+            if (irecipe == null) {
+               LOGGER.info("Skipping loading recipe {} as it's serializer returned null", minecraftkey);
+               continue;
+            }
+            // CraftBukkit start - SPIGOT-4638: last recipe gets priority
+            (map1.computeIfAbsent(irecipe.getType(), (recipes) -> {
+               return new Object2ObjectLinkedOpenHashMap<>();
+            })).putAndMoveToFirst(minecraftkey, irecipe);
+            // CraftBukkit end
+         } catch (IllegalArgumentException | JsonParseException jsonparseexception) {
+            String msg; if ((msg = jsonparseexception.getMessage()) == null || !msg.startsWith("Unknown item"))
+               LOGGER.error("Parsing error loading recipe {}", minecraftkey, jsonparseexception);
+         }
+      }
+   }
+
+   // CraftBukkit start
+   public void addRecipe(final IRecipe<?> irecipe) {
+      final Map<ResourceLocation, IRecipe<?>> map = this.recipes.get(irecipe.getType());
+      if (map.containsKey(irecipe.getId())) {
+         throw new IllegalStateException("Duplicate recipe ignored with ID " + irecipe.getId());
+      }
+      map.put(irecipe.getId(), irecipe); // CraftBukkit - SPIGOT-4638: last recipe gets priority
+   }
+   // CraftBukkit end
 
    public <C extends IInventory, T extends IRecipe<C>> Optional<T> getRecipeFor(IRecipeType<T> p_215371_1_, C p_215371_2_, World p_215371_3_) {
-      return this.byType(p_215371_1_).values().stream().flatMap((p_215372_3_) -> {
+      // CraftBukkit start
+      Optional<T> recipe = this.byType(p_215371_1_).values().stream().flatMap((p_215372_3_) -> {
          return Util.toStream(p_215371_1_.tryMatch(p_215372_3_, p_215371_3_, p_215371_2_));
       }).findFirst();
+      p_215371_2_.setCurrentRecipe(recipe.orElse(null)); // CraftBukkit - Clear recipe when no recipe is found
+      // CraftBukkit end
+      return recipe;
    }
 
    public <C extends IInventory, T extends IRecipe<C>> List<T> getAllRecipesFor(IRecipeType<T> p_241447_1_) {
@@ -89,7 +_,7 @@
    }
 
    private <C extends IInventory, T extends IRecipe<C>> Map<ResourceLocation, IRecipe<C>> byType(IRecipeType<T> p_215366_1_) {
-      return (Map)this.recipes.getOrDefault(p_215366_1_, Collections.emptyMap());
+      return (Map)this.recipes.getOrDefault(p_215366_1_, new Object2ObjectLinkedOpenHashMap<>()); // CraftBukkit
    }
 
    public <C extends IInventory, T extends IRecipe<C>> NonNullList<ItemStack> getRemainingItemsFor(IRecipeType<T> p_215369_1_, C p_215369_2_, World p_215369_3_) {
@@ -147,4 +_,14 @@
       });
       this.recipes = ImmutableMap.copyOf(map);
    }
+
+   // CraftBukkit start
+   public void clearRecipes() {
+      this.recipes = Maps.newHashMap();
+      for (IRecipeType<?> recipeType : Registry.RECIPE_TYPE) {
+         this.recipes.put(recipeType, Collections.emptyMap());
+      }
+   }
+   // CraftBukkit end
+
 }
