--- a/net/minecraft/world/gen/ChunkGenerator.java
+++ b/net/minecraft/world/gen/ChunkGenerator.java
@@ -9,6 +_,8 @@
 import java.util.function.Function;
 import java.util.function.Supplier;
 import javax.annotation.Nullable;
+
+import io.papermc.paper.event.world.StructureLocateEvent;
 import net.minecraft.crash.CrashReport;
 import net.minecraft.crash.CrashReportCategory;
 import net.minecraft.crash.ReportedException;
@@ -23,6 +_,7 @@
 import net.minecraft.world.IBlockReader;
 import net.minecraft.world.ISeedReader;
 import net.minecraft.world.IWorld;
+import net.minecraft.world.World;
 import net.minecraft.world.biome.Biome;
 import net.minecraft.world.biome.BiomeContainer;
 import net.minecraft.world.biome.BiomeGenerationSettings;
@@ -44,6 +_,8 @@
 import net.minecraft.world.server.ServerWorld;
 import net.minecraftforge.api.distmarker.Dist;
 import net.minecraftforge.api.distmarker.OnlyIn;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.v1_16_R3.CraftWorld;
 
 public abstract class ChunkGenerator {
    public static final Codec<ChunkGenerator> CODEC = Registry.CHUNK_GENERATOR.dispatchStable(ChunkGenerator::codec, Function.identity());
@@ -151,6 +_,28 @@
 
    @Nullable
    public BlockPos findNearestMapFeature(ServerWorld p_235956_1_, Structure<?> p_235956_2_, BlockPos p_235956_3_, int p_235956_4_, boolean p_235956_5_) {
+      // Paper start
+      org.bukkit.World bukkitWorld = p_235956_1_.getWorld();
+      org.bukkit.Location bukkitOrigin = new org.bukkit.Location(bukkitWorld, p_235956_3_.getX(), p_235956_3_.getY(), p_235956_3_.getZ());
+      StructureLocateEvent event = new StructureLocateEvent(bukkitWorld, bukkitOrigin, org.bukkit.StructureType.getStructureTypes().get(p_235956_2_.getFeatureName()), p_235956_4_, p_235956_5_);
+      if (!event.callEvent()) {
+         return null;
+      }
+      // If event call set a final location, skip structure finding and just return set result.
+      if (event.getResult() != null) {
+         return new BlockPos(event.getResult().getBlockX(), event.getResult().getBlockY(), event.getResult().getBlockZ());
+      }
+      // Get origin location (re)defined by event call.
+      p_235956_3_ = new BlockPos(event.getOrigin().getBlockX(), event.getOrigin().getBlockY(), event.getOrigin().getBlockZ());
+      // Get world (re)defined by event call.
+      p_235956_1_ = ((CraftWorld) event.getOrigin().getWorld()).getHandle();
+      // Get radius and whether to find unexplored structures (re)defined by event call.
+      p_235956_4_ = event.getRadius();
+      p_235956_5_ = event.shouldFindUnexplored();
+      //p_235956_2_ = Structure.STRUCTURES_REGISTRY.get(event.getType().getName());
+      // TODOï¼š Add Structure to StructureType(Bukkit)
+      if(event.getType() != null) p_235956_2_ = Structure.STRUCTURES_REGISTRY.get(event.getType().getName());
+      // Paper end
       if (!this.biomeSource.canGenerateStructure(p_235956_2_)) {
          return null;
       } else if (p_235956_2_ == Structure.STRONGHOLD) {
@@ -173,6 +_,7 @@
 
          return blockpos;
       } else {
+         updateStructureSettings(p_235956_1_, settings); // Spigot
          StructureSeparationSettings structureseparationsettings = this.settings.getConfig(p_235956_2_);
          return structureseparationsettings == null ? null : p_235956_2_.getNearestGeneratedFeature(p_235956_1_, p_235956_1_.structureFeatureManager(), p_235956_3_, p_235956_4_, p_235956_5_, p_235956_1_.getSeed(), structureseparationsettings);
       }
@@ -228,7 +_,16 @@
       this.createStructure(StructureFeatures.STRONGHOLD, p_242707_1_, p_242707_2_, p_242707_3_, p_242707_4_, p_242707_5_, chunkpos, biome);
 
       for(Supplier<StructureFeature<?, ?>> supplier : biome.getGenerationSettings().structures()) {
-         this.createStructure(supplier.get(), p_242707_1_, p_242707_2_, p_242707_3_, p_242707_4_, p_242707_5_, chunkpos, biome);
+         // CraftBukkit start
+         StructureFeature<?, ?> structurefeature = (StructureFeature) supplier.get();
+         if (structurefeature.config == Structure.STRONGHOLD) {
+            synchronized (structurefeature) {
+               this.createStructure(structurefeature, p_242707_1_, p_242707_2_, p_242707_3_, p_242707_4_, p_242707_5_, chunkpos, biome);
+            }
+         } else {
+            this.createStructure(structurefeature, p_242707_1_, p_242707_2_, p_242707_3_, p_242707_4_, p_242707_5_, chunkpos, biome);
+         }
+         // CraftBukkit end
       }
 
    }
@@ -236,6 +_,7 @@
    private void createStructure(StructureFeature<?, ?> p_242705_1_, DynamicRegistries p_242705_2_, StructureManager p_242705_3_, IChunk p_242705_4_, TemplateManager p_242705_5_, long p_242705_6_, ChunkPos p_242705_8_, Biome p_242705_9_) {
       StructureStart<?> structurestart = p_242705_3_.getStartForFeature(SectionPos.of(p_242705_4_.getPos(), 0), p_242705_1_.feature, p_242705_4_);
       int i = structurestart != null ? structurestart.getReferences() : 0;
+      updateStructureSettings(p_242705_3_.getWorld(), settings); // Spigot
       StructureSeparationSettings structureseparationsettings = this.settings.getConfig(p_242705_1_.feature);
       if (structureseparationsettings != null) {
          StructureStart<?> structurestart1 = p_242705_1_.generate(p_242705_2_, this, this.biomeSource, p_242705_5_, p_242705_6_, p_242705_8_, p_242705_9_, i, structureseparationsettings);
@@ -281,6 +_,79 @@
       }
 
    }
+
+   // Spigot start
+   private volatile boolean injected;
+   private void updateStructureSettings(World world, DimensionStructuresSettings settings) {
+      if (injected) {
+         return;
+      }
+      synchronized (settings) {
+         if (injected) {
+            return;
+         }
+         java.util.Map<Structure<?>, StructureSeparationSettings> original = settings.structureConfig();
+         java.util.Map<Structure<?>, StructureSeparationSettings> updated = new java.util.HashMap<>();
+         org.spigotmc.SpigotWorldConfig conf = world.spigotConfig;
+         for (java.util.Map.Entry<Structure<?>, StructureSeparationSettings> entry : original.entrySet()) {
+            String name = Registry.STRUCTURE_FEATURE.getKey(entry.getKey()).getPath();
+            StructureSeparationSettings feature = entry.getValue();
+            int seed = feature.salt();
+            switch (name) {
+               case "bastion_remnant":
+                  seed = conf.bastionSeed;
+                  break;
+               case "desert_pyramid":
+                  seed = conf.desertSeed;
+                  break;
+               case "endcity":
+                  seed = conf.endCitySeed;
+                  break;
+               case "fortress":
+                  seed = conf.fortressSeed;
+                  break;
+               case "igloo":
+                  seed = conf.iglooSeed;
+                  break;
+               case "jungle_pyramid":
+                  seed = conf.jungleSeed;
+                  break;
+               case "mansion":
+                  seed = conf.mansionSeed;
+                  break;
+               case "monument":
+                  seed = conf.monumentSeed;
+                  break;
+               case "nether_fossil":
+                  seed = conf.fossilSeed;
+                  break;
+               case "ocean_ruin":
+                  seed = conf.oceanSeed;
+                  break;
+               case "pillager_outpost":
+                  seed = conf.outpostSeed;
+                  break;
+               case "ruined_portal":
+                  seed = conf.portalSeed;
+                  break;
+               case "shipwreck":
+                  seed = conf.shipwreckSeed;
+                  break;
+               case "swamp_hut":
+                  seed = conf.swampSeed;
+                  break;
+               case "village":
+                  seed = conf.villageSeed;
+                  break;
+            }
+            updated.put(entry.getKey(), new StructureSeparationSettings(feature.spacing(), feature.separation(), seed));
+         }
+         original.clear();
+         original.putAll(updated);
+         injected = true;
+      }
+   }
+   // Spigot end
 
    public abstract void fillFromNoise(IWorld p_230352_1_, StructureManager p_230352_2_, IChunk p_230352_3_);
 
