--- a/net/minecraft/world/chunk/Chunk.java
+++ b/net/minecraft/world/chunk/Chunk.java
@@ -20,7 +_,7 @@
 import net.minecraft.block.Block;
 import net.minecraft.block.BlockState;
 import net.minecraft.block.Blocks;
-import net.minecraft.block.ITileEntityProvider;
+import net.minecraft.block.ContainerBlock;
 import net.minecraft.crash.CrashReport;
 import net.minecraft.crash.CrashReportCategory;
 import net.minecraft.crash.ReportedException;
@@ -57,20 +_,21 @@
 import net.minecraftforge.api.distmarker.OnlyIn;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.bukkit.craftbukkit.v1_16_R3.CraftChunk;
 
-public class Chunk implements IChunk {
+public class Chunk extends net.minecraftforge.common.capabilities.CapabilityProvider<Chunk> implements IChunk, net.minecraftforge.common.extensions.IForgeChunk {
    private static final Logger LOGGER = LogManager.getLogger();
    @Nullable
    public static final ChunkSection EMPTY_SECTION = null;
    private final ChunkSection[] sections = new ChunkSection[16];
    private BiomeContainer biomes;
    private final Map<BlockPos, CompoundNBT> pendingBlockEntities = Maps.newHashMap();
-   private boolean loaded;
-   private final World level;
-   private final Map<Heightmap.Type, Heightmap> heightmaps = Maps.newEnumMap(Heightmap.Type.class);
+   public boolean loaded;
+   public final World level;
+   public final Map<Heightmap.Type, Heightmap> heightmaps = Maps.newEnumMap(Heightmap.Type.class);
    private final UpgradeData upgradeData;
-   private final Map<BlockPos, TileEntity> blockEntities = Maps.newHashMap();
-   private final ClassInheritanceMultiMap<Entity>[] entitySections;
+   public final Map<BlockPos, TileEntity> blockEntities = Maps.newHashMap();
+   public final ClassInheritanceMultiMap<Entity>[] entitySections;
    private final Map<Structure<?>, StructureStart<?>> structureStarts = Maps.newHashMap();
    private final Map<Structure<?>, LongSet> structuresRefences = Maps.newHashMap();
    private final ShortList[] postProcessing = new ShortList[16];
@@ -86,12 +_,14 @@
    private Consumer<Chunk> postLoad;
    private final ChunkPos chunkPos;
    private volatile boolean isLightCorrect;
+   public final ServerWorld world_cb; // LoliServer - CraftBukkit cast to ServerWorld, add a field make sure plugin compatibility
 
    public Chunk(World p_i225780_1_, ChunkPos p_i225780_2_, BiomeContainer p_i225780_3_) {
       this(p_i225780_1_, p_i225780_2_, p_i225780_3_, UpgradeData.EMPTY, EmptyTickList.empty(), EmptyTickList.empty(), 0L, (ChunkSection[])null, (Consumer<Chunk>)null);
    }
 
    public Chunk(World p_i225781_1_, ChunkPos p_i225781_2_, BiomeContainer p_i225781_3_, UpgradeData p_i225781_4_, ITickList<Block> p_i225781_5_, ITickList<Fluid> p_i225781_6_, long p_i225781_7_, @Nullable ChunkSection[] p_i225781_9_, @Nullable Consumer<Chunk> p_i225781_10_) {
+      super(Chunk.class);
       this.entitySections = new ClassInheritanceMultiMap[16];
       this.level = p_i225781_1_;
       this.chunkPos = p_i225781_2_;
@@ -119,8 +_,24 @@
             LOGGER.warn("Could not set level chunk sections, array length is {} instead of {}", p_i225781_9_.length, this.sections.length);
          }
       }
-
-   }
+      this.gatherCapabilities();
+
+      // CraftBukkit start
+      this.bukkitChunk = new CraftChunk(this);
+      this.world_cb = p_i225781_1_ instanceof ServerWorld ? (ServerWorld) p_i225781_1_ : null; // LoliServer - TODO: Plugin may be NPE (
+   }
+
+   public org.bukkit.Chunk bukkitChunk;
+   public org.bukkit.Chunk getBukkitChunk() {
+      return bukkitChunk;
+   }
+
+   public boolean mustNotSave;
+   public boolean needsDecoration;
+
+   private static final org.bukkit.craftbukkit.v1_16_R3.persistence.CraftPersistentDataTypeRegistry DATA_TYPE_REGISTRY = new org.bukkit.craftbukkit.v1_16_R3.persistence.CraftPersistentDataTypeRegistry();
+   public final org.bukkit.craftbukkit.v1_16_R3.persistence.CraftPersistentDataContainer persistentDataContainer = new org.bukkit.craftbukkit.v1_16_R3.persistence.CraftPersistentDataContainer(DATA_TYPE_REGISTRY);
+   // CraftBukkit end
 
    public Chunk(World p_i49947_1_, ChunkPrimer p_i49947_2_) {
       this(p_i49947_1_, p_i49947_2_.getPos(), p_i49947_2_.getBiomes(), p_i49947_2_.getUpgradeData(), p_i49947_2_.getBlockTicks(), p_i49947_2_.getLiquidTicks(), p_i49947_2_.getInhabitedTime(), p_i49947_2_.getSections(), (Consumer<Chunk>)null);
@@ -153,6 +_,7 @@
 
       this.setLightCorrect(p_i49947_2_.isLightCorrect());
       this.unsaved = true;
+      this.needsDecoration = true; // CraftBukkit
    }
 
    public Heightmap getOrCreateHeightmapUnprimed(Heightmap.Type p_217303_1_) {
@@ -231,14 +_,25 @@
       }
    }
 
+   // CraftBukkit start
+   public boolean catserver$doPlace = true;
    @Nullable
    public BlockState setBlockState(BlockPos p_177436_1_, BlockState p_177436_2_, boolean p_177436_3_) {
-      int i = p_177436_1_.getX() & 15;
-      int j = p_177436_1_.getY();
-      int k = p_177436_1_.getZ() & 15;
+      return this.setBlockState(p_177436_1_, p_177436_2_, p_177436_3_, catserver$doPlace);
+   }
+
+   public BlockState setType(BlockPos pos, BlockState state, boolean isMoving, boolean doPlace) {
+       return this.setBlockState(pos, state, isMoving, doPlace);
+   }
+
+   public BlockState setBlockState(BlockPos pos, BlockState state, boolean isMoving, boolean doPlace) {
+      // CraftBukkit end
+      int i = pos.getX() & 15;
+      int j = pos.getY();
+      int k = pos.getZ() & 15;
       ChunkSection chunksection = this.sections[j >> 4];
       if (chunksection == EMPTY_SECTION) {
-         if (p_177436_2_.isAir()) {
+         if (state.isAir()) {
             return null;
          }
 
@@ -247,46 +_,47 @@
       }
 
       boolean flag = chunksection.isEmpty();
-      BlockState blockstate = chunksection.setBlockState(i, j & 15, k, p_177436_2_);
-      if (blockstate == p_177436_2_) {
+      BlockState blockstate = chunksection.setBlockState(i, j & 15, k, state);
+      if (blockstate == state) {
          return null;
       } else {
-         Block block = p_177436_2_.getBlock();
+         Block block = state.getBlock();
          Block block1 = blockstate.getBlock();
-         this.heightmaps.get(Heightmap.Type.MOTION_BLOCKING).update(i, j, k, p_177436_2_);
-         this.heightmaps.get(Heightmap.Type.MOTION_BLOCKING_NO_LEAVES).update(i, j, k, p_177436_2_);
-         this.heightmaps.get(Heightmap.Type.OCEAN_FLOOR).update(i, j, k, p_177436_2_);
-         this.heightmaps.get(Heightmap.Type.WORLD_SURFACE).update(i, j, k, p_177436_2_);
+         this.heightmaps.get(Heightmap.Type.MOTION_BLOCKING).update(i, j, k, state);
+         this.heightmaps.get(Heightmap.Type.MOTION_BLOCKING_NO_LEAVES).update(i, j, k, state);
+         this.heightmaps.get(Heightmap.Type.OCEAN_FLOOR).update(i, j, k, state);
+         this.heightmaps.get(Heightmap.Type.WORLD_SURFACE).update(i, j, k, state);
          boolean flag1 = chunksection.isEmpty();
          if (flag != flag1) {
-            this.level.getChunkSource().getLightEngine().updateSectionStatus(p_177436_1_, flag1);
+            this.level.getChunkSource().getLightEngine().updateSectionStatus(pos, flag1);
          }
 
          if (!this.level.isClientSide) {
-            blockstate.onRemove(this.level, p_177436_1_, p_177436_2_, p_177436_3_);
-         } else if (block1 != block && block1 instanceof ITileEntityProvider) {
-            this.level.removeBlockEntity(p_177436_1_);
+            blockstate.onRemove(this.level, pos, state, isMoving);
+         } else if ((block1 != block || !state.hasTileEntity()) && blockstate.hasTileEntity()) {
+            this.level.removeBlockEntity(pos);
          }
 
          if (!chunksection.getBlockState(i, j & 15, k).is(block)) {
             return null;
          } else {
-            if (block1 instanceof ITileEntityProvider) {
-               TileEntity tileentity = this.getBlockEntity(p_177436_1_, Chunk.CreateEntityType.CHECK);
+            if (blockstate.hasTileEntity()) {
+               TileEntity tileentity = this.getBlockEntity(pos, Chunk.CreateEntityType.CHECK);
                if (tileentity != null) {
                   tileentity.clearCache();
                }
             }
 
-            if (!this.level.isClientSide) {
-               p_177436_2_.onPlace(this.level, p_177436_1_, blockstate, p_177436_3_);
+            // CraftBukkit - Don't place while processing the BlockPlaceEvent, unless it's a BlockContainer. Prevents blocks such as TNT from activating when cancelled.
+            if (!this.level.isClientSide && doPlace && !this.level.captureBlockSnapshots && (!this.level.captureBlockStates || block instanceof ContainerBlock)) {
+               state.onPlace(this.level, pos, blockstate, isMoving);
             }
 
-            if (block instanceof ITileEntityProvider) {
-               TileEntity tileentity1 = this.getBlockEntity(p_177436_1_, Chunk.CreateEntityType.CHECK);
+            if (state.hasTileEntity()) {
+               TileEntity tileentity1 = this.getBlockEntity(pos, Chunk.CreateEntityType.CHECK);
                if (tileentity1 == null) {
-                  tileentity1 = ((ITileEntityProvider)block).newBlockEntity(this.level);
-                  this.level.setBlockEntity(p_177436_1_, tileentity1);
+                  tileentity1 = state.createTileEntity(this.level);
+                  this.level.setBlockEntity(pos, tileentity1);
                } else {
                   tileentity1.clearCache();
                }
@@ -321,11 +_,13 @@
          k = this.entitySections.length - 1;
       }
 
+      net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.entity.EntityEvent.EnteringChunk(p_76612_1_, this.chunkPos.x, this.chunkPos.z, p_76612_1_.xChunk, p_76612_1_.zChunk));
       p_76612_1_.inChunk = true;
       p_76612_1_.xChunk = this.chunkPos.x;
       p_76612_1_.yChunk = k;
       p_76612_1_.zChunk = this.chunkPos.z;
       this.entitySections[k].add(p_76612_1_);
+      this.markUnsaved(); // Forge - ensure chunks are marked to save after an entity add
    }
 
    public void setHeightmap(Heightmap.Type p_201607_1_, long[] p_201607_2_) {
@@ -346,6 +_,7 @@
       }
 
       this.entitySections[p_76608_2_].remove(p_76608_1_);
+      this.markUnsaved(); // Forge - ensure chunks are marked to save after entity removals
    }
 
    public int getHeight(Heightmap.Type p_201576_1_, int p_201576_2_, int p_201576_3_) {
@@ -356,7 +_,7 @@
    private TileEntity createBlockEntity(BlockPos p_177422_1_) {
       BlockState blockstate = this.getBlockState(p_177422_1_);
       Block block = blockstate.getBlock();
-      return !block.isEntityBlock() ? null : ((ITileEntityProvider)block).newBlockEntity(this.level);
+      return !blockstate.hasTileEntity() ? null : blockstate.createTileEntity(this.level);
    }
 
    @Nullable
@@ -366,7 +_,17 @@
 
    @Nullable
    public TileEntity getBlockEntity(BlockPos p_177424_1_, Chunk.CreateEntityType p_177424_2_) {
-      TileEntity tileentity = this.blockEntities.get(p_177424_1_);
+      // CraftBukkit start
+      TileEntity tileentity = level.capturedTileEntities.get(p_177424_1_);
+      if (tileentity == null) {
+         tileentity = (TileEntity) this.blockEntities.get(p_177424_1_);
+      }
+      // CraftBukkit end
+
+      if (tileentity != null && tileentity.isRemoved()) {
+         blockEntities.remove(p_177424_1_);
+         tileentity = null;
+      }
       if (tileentity == null) {
          CompoundNBT compoundnbt = this.pendingBlockEntities.remove(p_177424_1_);
          if (compoundnbt != null) {
@@ -382,9 +_,6 @@
             tileentity = this.createBlockEntity(p_177424_1_);
             this.level.setBlockEntity(p_177424_1_, tileentity);
          }
-      } else if (tileentity.isRemoved()) {
-         this.blockEntities.remove(p_177424_1_);
-         return null;
       }
 
       return tileentity;
@@ -399,14 +_,13 @@
    }
 
    public void setBlockEntity(BlockPos p_177426_1_, TileEntity p_177426_2_) {
-      if (this.getBlockState(p_177426_1_).getBlock() instanceof ITileEntityProvider) {
+      if (this.getBlockState(p_177426_1_).hasTileEntity()) {
          p_177426_2_.setLevelAndPosition(this.level, p_177426_1_);
          p_177426_2_.clearRemoved();
          TileEntity tileentity = this.blockEntities.put(p_177426_1_.immutable(), p_177426_2_);
          if (tileentity != null && tileentity != p_177426_2_) {
             tileentity.setRemoved();
          }
-
       }
    }
 
@@ -418,9 +_,14 @@
    public CompoundNBT getBlockEntityNbtForSaving(BlockPos p_223134_1_) {
       TileEntity tileentity = this.getBlockEntity(p_223134_1_);
       if (tileentity != null && !tileentity.isRemoved()) {
+         try {
          CompoundNBT compoundnbt1 = tileentity.save(new CompoundNBT());
          compoundnbt1.putBoolean("keepPacked", false);
          return compoundnbt1;
+         } catch (Exception e) {
+            LogManager.getLogger().error("A TileEntity type {} has thrown an exception trying to write state. It will not persist, Report this to the mod author", tileentity.getClass().getName(), e);
+            return null;
+         }
       } else {
          CompoundNBT compoundnbt = this.pendingBlockEntities.get(p_223134_1_);
          if (compoundnbt != null) {
@@ -450,13 +_,55 @@
 
    }
 
+   // CraftBukkit start
+   public void loadCallback() {
+      org.bukkit.Server server = this.level.getCBServer();
+      if (server != null) {
+         /*
+          * If it's a new world, the first few chunks are generated inside
+          * the World constructor. We can't reliably alter that, so we have
+          * no way of creating a CraftWorld/CraftServer at that point.
+          */
+         server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkLoadEvent(this.bukkitChunk, this.needsDecoration));
+         if (this.needsDecoration) {
+            this.needsDecoration = false;
+            java.util.Random random = new java.util.Random();
+            random.setSeed(((ServerWorld) level).getSeed());
+            long xRand = random.nextLong() / 2L * 2L + 1L;
+            long zRand = random.nextLong() / 2L * 2L + 1L;
+            random.setSeed((long) this.chunkPos.x * xRand + (long) this.chunkPos.z * zRand ^ ((ServerWorld) level).getSeed());
+
+            org.bukkit.World world = this.level.getWorld();
+            if (world != null) {
+               this.level.populating = true;
+               try {
+                  for (org.bukkit.generator.BlockPopulator populator : world.getPopulators()) {
+                     populator.populate(world, random, bukkitChunk);
+                  }
+               } finally {
+                  this.level.populating = false;
+               }
+            }
+            server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkPopulateEvent(bukkitChunk));
+         }
+      }
+   }
+   public void unloadCallback() {
+      org.bukkit.Server server = this.level.getCBServer();
+      org.bukkit.event.world.ChunkUnloadEvent unloadEvent = new org.bukkit.event.world.ChunkUnloadEvent(this.bukkitChunk, this.isUnsaved());
+      server.getPluginManager().callEvent(unloadEvent);
+      // note: saving can be prevented, but not forced if no saving is actually required
+      this.mustNotSave = !unloadEvent.isSaveChunk();
+   }
+   // CraftBukkit end
+
    public void markUnsaved() {
       this.unsaved = true;
    }
 
    public void getEntities(@Nullable Entity p_177414_1_, AxisAlignedBB p_177414_2_, List<Entity> p_177414_3_, @Nullable Predicate<? super Entity> p_177414_4_) {
-      int i = MathHelper.floor((p_177414_2_.minY - 2.0D) / 16.0D);
-      int j = MathHelper.floor((p_177414_2_.maxY + 2.0D) / 16.0D);
+      int i = MathHelper.floor((p_177414_2_.minY - this.level.getMaxEntityRadius()) / 16.0D);
+      int j = MathHelper.floor((p_177414_2_.maxY + this.level.getMaxEntityRadius()) / 16.0D);
       i = MathHelper.clamp(i, 0, this.entitySections.length - 1);
       j = MathHelper.clamp(j, 0, this.entitySections.length - 1);
 
@@ -472,6 +_,7 @@
                   p_177414_3_.add(entity);
                }
 
+               if (false) // Forge: Fix MC-158205: Moved into World.getEntities()
                if (entity instanceof EnderDragonEntity) {
                   for(EnderDragonPartEntity enderdragonpartentity : ((EnderDragonEntity)entity).getSubEntities()) {
                      if (enderdragonpartentity != p_177414_1_ && enderdragonpartentity.getBoundingBox().intersects(p_177414_2_) && (p_177414_4_ == null || p_177414_4_.test(enderdragonpartentity))) {
@@ -486,8 +_,8 @@
    }
 
    public <T extends Entity> void getEntities(@Nullable EntityType<?> p_217313_1_, AxisAlignedBB p_217313_2_, List<? super T> p_217313_3_, Predicate<? super T> p_217313_4_) {
-      int i = MathHelper.floor((p_217313_2_.minY - 2.0D) / 16.0D);
-      int j = MathHelper.floor((p_217313_2_.maxY + 2.0D) / 16.0D);
+      int i = MathHelper.floor((p_217313_2_.minY - this.level.getMaxEntityRadius()) / 16.0D);
+      int j = MathHelper.floor((p_217313_2_.maxY + this.level.getMaxEntityRadius()) / 16.0D);
       i = MathHelper.clamp(i, 0, this.entitySections.length - 1);
       j = MathHelper.clamp(j, 0, this.entitySections.length - 1);
 
@@ -502,8 +_,8 @@
    }
 
    public <T extends Entity> void getEntitiesOfClass(Class<? extends T> p_177430_1_, AxisAlignedBB p_177430_2_, List<T> p_177430_3_, @Nullable Predicate<? super T> p_177430_4_) {
-      int i = MathHelper.floor((p_177430_2_.minY - 2.0D) / 16.0D);
-      int j = MathHelper.floor((p_177430_2_.maxY + 2.0D) / 16.0D);
+      int i = MathHelper.floor((p_177430_2_.minY - this.level.getMaxEntityRadius()) / 16.0D);
+      int j = MathHelper.floor((p_177430_2_.maxY + this.level.getMaxEntityRadius()) / 16.0D);
       i = MathHelper.clamp(i, 0, this.entitySections.length - 1);
       j = MathHelper.clamp(j, 0, this.entitySections.length - 1);
 
@@ -535,6 +_,11 @@
       };
       Sets.newHashSet(this.blockEntities.keySet()).stream().filter(predicate).forEach(this.level::removeBlockEntity);
 
+      for (TileEntity tileEntity : blockEntities.values()) {
+         tileEntity.clearCache();
+         tileEntity.getBlockState();
+      }
+
       for(int i = 0; i < this.sections.length; ++i) {
          ChunkSection chunksection = this.sections[i];
          if ((p_227073_4_ & 1 << i) == 0) {
@@ -598,7 +_,7 @@
 
    public Stream<BlockPos> getLights() {
       return StreamSupport.stream(BlockPos.betweenClosed(this.chunkPos.getMinBlockX(), 0, this.chunkPos.getMinBlockZ(), this.chunkPos.getMaxBlockX(), 255, this.chunkPos.getMaxBlockZ()).spliterator(), false).filter((p_217312_1_) -> {
-         return this.getBlockState(p_217312_1_).getLightEmission() != 0;
+         return this.getBlockState(p_217312_1_).getLightValue(getLevel(), p_217312_1_) != 0;
       });
    }
 
@@ -615,7 +_,7 @@
    }
 
    public boolean isUnsaved() {
-      return this.unsaved || this.lastSaveHadEntities && this.level.getGameTime() != this.lastSaveTime;
+      return (this.unsaved || this.lastSaveHadEntities && this.level.getGameTime() != this.lastSaveTime) && !this.mustNotSave; // CraftBukkit
    }
 
    public void setLastSaveHadEntities(boolean p_177409_1_) {
@@ -704,9 +_,8 @@
       BlockState blockstate = this.getBlockState(p_212815_1_);
       TileEntity tileentity;
       if ("DUMMY".equals(p_212815_2_.getString("id"))) {
-         Block block = blockstate.getBlock();
-         if (block instanceof ITileEntityProvider) {
-            tileentity = ((ITileEntityProvider)block).newBlockEntity(this.level);
+         if (blockstate.hasTileEntity()) {
+            tileentity = blockstate.createTileEntity(this.level);
          } else {
             tileentity = null;
             LOGGER.warn("Tried to load a DUMMY block entity @ {} but found not block entity block {} at location", p_212815_1_, blockstate);
@@ -794,5 +_,31 @@
       IMMEDIATE,
       QUEUED,
       CHECK;
+   }
+
+   /**
+    * <strong>FOR INTERNAL USE ONLY</strong>
+    * <p>
+    * Only public for use in {@link AnvilChunkLoader}.
+    */
+   @java.lang.Deprecated
+   @javax.annotation.Nullable
+   public final CompoundNBT writeCapsToNBT() {
+      return this.serializeCaps();
+   }
+
+   /**
+    * <strong>FOR INTERNAL USE ONLY</strong>
+    * <p>
+    * Only public for use in {@link AnvilChunkLoader}.
+    */
+   @java.lang.Deprecated
+   public final void readCapsFromNBT(CompoundNBT tag) {
+      this.deserializeCaps(tag);
+   }
+
+   @Override
+   public World getWorldForge() {
+      return getLevel();
    }
 }
