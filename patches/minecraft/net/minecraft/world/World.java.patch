--- a/net/minecraft/world/World.java
+++ b/net/minecraft/world/World.java
@@ -1,11 +_,15 @@
 package net.minecraft.world;
 
 import com.google.common.collect.Lists;
+import moe.loliserver.BukkitInjector;
 import com.mojang.serialization.Codec;
 import java.io.IOException;
 import java.util.Collection;
+import java.util.HashMap;
 import java.util.Iterator;
+import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.Random;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
@@ -20,6 +_,7 @@
 import net.minecraft.crash.ReportedException;
 import net.minecraft.entity.Entity;
 import net.minecraft.entity.EntityType;
+import net.minecraft.entity.item.ItemEntity;
 import net.minecraft.entity.player.PlayerEntity;
 import net.minecraft.fluid.FluidState;
 import net.minecraft.fluid.Fluids;
@@ -34,7 +_,6 @@
 import net.minecraft.tags.ITagCollectionSupplier;
 import net.minecraft.tileentity.ITickableTileEntity;
 import net.minecraft.tileentity.TileEntity;
-import net.minecraft.tileentity.TileEntityType;
 import net.minecraft.util.DamageSource;
 import net.minecraft.util.Direction;
 import net.minecraft.util.RegistryKey;
@@ -55,6 +_,8 @@
 import net.minecraft.world.gen.Heightmap;
 import net.minecraft.world.lighting.WorldLightManager;
 import net.minecraft.world.server.ChunkHolder;
+import net.minecraft.world.server.ServerWorld;
+import net.minecraft.world.storage.IServerWorldInfo;
 import net.minecraft.world.storage.ISpawnWorldInfo;
 import net.minecraft.world.storage.IWorldInfo;
 import net.minecraft.world.storage.MapData;
@@ -62,8 +_,16 @@
 import net.minecraftforge.api.distmarker.OnlyIn;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.v1_16_R3.CraftServer;
+import org.bukkit.craftbukkit.v1_16_R3.CraftWorld;
+import org.bukkit.craftbukkit.v1_16_R3.SpigotTimings;
+import org.bukkit.craftbukkit.v1_16_R3.block.CapturedBlockState;
+import org.bukkit.craftbukkit.v1_16_R3.block.data.CraftBlockData;
+import org.bukkit.event.block.BlockPhysicsEvent;
+import org.bukkit.generator.ChunkGenerator;
 
-public abstract class World implements IWorld, AutoCloseable {
+public abstract class World extends net.minecraftforge.common.capabilities.CapabilityProvider<World> implements IWorld, AutoCloseable, net.minecraftforge.common.extensions.IForgeWorld {
    protected static final Logger LOGGER = LogManager.getLogger();
    public static final Codec<RegistryKey<World>> RESOURCE_KEY_CODEC = ResourceLocation.CODEC.xmap(RegistryKey.elementKey(Registry.DIMENSION_REGISTRY), RegistryKey::location);
    public static final RegistryKey<World> OVERWORLD = RegistryKey.create(Registry.DIMENSION_REGISTRY, new ResourceLocation("overworld"));
@@ -73,8 +_,8 @@
    public final List<TileEntity> blockEntityList = Lists.newArrayList();
    public final List<TileEntity> tickableBlockEntities = Lists.newArrayList();
    protected final List<TileEntity> pendingBlockEntities = Lists.newArrayList();
-   protected final List<TileEntity> blockEntitiesToUnload = Lists.newArrayList();
-   private final Thread thread;
+   protected final java.util.Set<TileEntity> blockEntitiesToUnload = java.util.Collections.newSetFromMap(new java.util.IdentityHashMap<>()); // Forge: faster "contains" makes removal much more efficient
+   public final Thread thread;
    private final boolean isDebug;
    private int skyDarken;
    protected int randValue = (new Random()).nextInt();
@@ -85,15 +_,119 @@
    public float thunderLevel;
    public final Random random = new Random();
    private final DimensionType dimensionType;
-   protected final ISpawnWorldInfo levelData;
+   public final ISpawnWorldInfo levelData;
    private final Supplier<IProfiler> profiler;
    public final boolean isClientSide;
    protected boolean updatingBlockEntities;
    private final WorldBorder worldBorder;
    private final BiomeManager biomeManager;
    private final RegistryKey<World> dimension;
+   public boolean restoringBlockSnapshots = false;
+   public boolean captureBlockSnapshots = false;
+   public java.util.ArrayList<net.minecraftforge.common.util.BlockSnapshot> capturedBlockSnapshots = new java.util.ArrayList<>();
+
+   // CraftBukkit start Added the following
+   private RegistryKey<DimensionType> typeKey;
+   public CraftWorld craftWorld;
+   public boolean pvpMode;
+   public boolean keepSpawnInMemory = true;
+   public org.bukkit.generator.ChunkGenerator generator = catserver.server.utils.BukkitWorldSetter.get().getChunkGenerator(); // CatServer
+   public org.bukkit.World.Environment environment = catserver.server.utils.BukkitWorldSetter.get().getEnvironment(); // CatServer
+   public boolean captureBlockStates = false;
+   public boolean captureTreeGeneration = false;
+   public Map<BlockPos, CapturedBlockState> capturedBlockStates = new LinkedHashMap<>();
+   public Map<BlockPos, TileEntity> capturedTileEntities = new HashMap<>();
+   public List<ItemEntity> captureDrops;
+   public long ticksPerAnimalSpawns;
+   public long ticksPerMonsterSpawns;
+   public long ticksPerWaterSpawns;
+   public long ticksPerWaterAmbientSpawns;
+   public long ticksPerAmbientSpawns;
+   public boolean populating;
+   public org.spigotmc.SpigotWorldConfig spigotConfig; // Spigot
+   public static BlockPos lastPhysicsProblem; // Spigot
+   protected org.spigotmc.TickLimiter entityLimiter;
+   protected org.spigotmc.TickLimiter tileLimiter;
+   private int tileTickPosition;
+   public final Map<Explosion.CacheKey, Float> explosionDensityCache = new HashMap<>(); // Paper - Optimize explosions
+
+   public boolean pehkuiExplosionFire = false; // Fix Pehkui Startup
+
+   public SpigotTimings.WorldTimingsHandler timings; // Spigot
+
+   public CraftWorld getWorld(){
+      return this.craftWorld;
+   }
+
+   public CraftServer getCBServer() {
+      return (CraftServer) Bukkit.getServer();
+   }
+
+   public RegistryKey<DimensionType> getTypeKey() {
+      return typeKey;
+   }
 
    protected World(ISpawnWorldInfo p_i241925_1_, RegistryKey<World> p_i241925_2_, final DimensionType p_i241925_3_, Supplier<IProfiler> p_i241925_4_, boolean p_i241925_5_, boolean p_i241925_6_, long p_i241925_7_) {
+      super(World.class);
+      this.ticksPerAnimalSpawns = this.getCBServer().getTicksPerAnimalSpawns(); // CraftBukkit
+      this.ticksPerMonsterSpawns = this.getCBServer().getTicksPerMonsterSpawns(); // CraftBukkit
+      this.ticksPerWaterSpawns = this.getCBServer().getTicksPerWaterSpawns(); // CraftBukkit
+      this.ticksPerWaterAmbientSpawns = this.getCBServer().getTicksPerWaterAmbientSpawns(); // CraftBukkit
+      this.ticksPerAmbientSpawns = this.getCBServer().getTicksPerAmbientSpawns(); // CraftBukkit
+      MinecraftServer.getServer().registryAccess().dimensionTypes().entrySet().stream().filter(entry -> entry.getValue() == p_i241925_3_).forEachOrdered(entry -> this.typeKey = entry.getKey());
+      if (generator == null && p_i241925_1_ != null) {
+         generator = getCBServer().getGenerator(((IServerWorldInfo) p_i241925_1_).getLevelName());
+      }
+      if (environment == null) {
+         environment = BukkitInjector.environment.get(getTypeKey());
+      }
+      // CraftBukkit end
+      this.profiler = p_i241925_4_;
+      this.levelData = p_i241925_1_;
+      this.dimensionType = p_i241925_3_;
+      this.dimension = p_i241925_2_;
+      this.isClientSide = p_i241925_5_;
+      if (p_i241925_3_.coordinateScale() != 1.0D) {
+         this.worldBorder = new WorldBorder() {
+            public double getCenterX() {
+               return super.getCenterX() / p_i241925_3_.coordinateScale();
+            }
+
+            public double getCenterZ() {
+               return super.getCenterZ() / p_i241925_3_.coordinateScale();
+            }
+         };
+      } else {
+         this.worldBorder = new WorldBorder();
+      }
+
+      this.thread = Thread.currentThread();
+      this.biomeManager = new BiomeManager(this, p_i241925_7_, p_i241925_3_.getBiomeZoomer());
+      this.isDebug = p_i241925_6_;
+   }
+
+
+   protected World(ISpawnWorldInfo p_i241925_1_, RegistryKey<World> p_i241925_2_, final DimensionType p_i241925_3_, Supplier<IProfiler> p_i241925_4_, boolean p_i241925_5_, boolean p_i241925_6_, long p_i241925_7_, org.bukkit.World.Environment cbEnv, ChunkGenerator cbChunkGen) {
+      super(World.class);
+      if (cbChunkGen != null) {
+         this.generator = cbChunkGen;
+      }
+      if (cbEnv != null) {
+         this.environment = cbEnv;
+      }
+      this.ticksPerAnimalSpawns = this.getCBServer().getTicksPerAnimalSpawns(); // CraftBukkit
+      this.ticksPerMonsterSpawns = this.getCBServer().getTicksPerMonsterSpawns(); // CraftBukkit
+      this.ticksPerWaterSpawns = this.getCBServer().getTicksPerWaterSpawns(); // CraftBukkit
+      this.ticksPerWaterAmbientSpawns = this.getCBServer().getTicksPerWaterAmbientSpawns(); // CraftBukkit
+      this.ticksPerAmbientSpawns = this.getCBServer().getTicksPerAmbientSpawns(); // CraftBukkit
+      MinecraftServer.getServer().registryAccess().dimensionTypes().entrySet().stream().filter(entry -> entry.getValue() == p_i241925_3_).forEachOrdered(entry -> this.typeKey = entry.getKey());
+      if (generator == null && p_i241925_1_ != null) {
+         generator = getCBServer().getGenerator(((IServerWorldInfo) p_i241925_1_).getLevelName());
+      }
+      if (environment == null) {
+         environment = BukkitInjector.environment.get(getTypeKey());
+      }
+      // CraftBukkit end
       this.profiler = p_i241925_4_;
       this.levelData = p_i241925_1_;
       this.dimensionType = p_i241925_3_;
@@ -155,6 +_,10 @@
       return this.getChunk(p_175726_1_.getX() >> 4, p_175726_1_.getZ() >> 4);
    }
 
+   public Chunk getChunkAt(int chunkX, int chunkZ) {
+       return this.getChunk(chunkX, chunkZ);
+   }
+
    public Chunk getChunk(int p_212866_1_, int p_212866_2_) {
       return (Chunk)this.getChunk(p_212866_1_, p_212866_2_, ChunkStatus.FULL);
    }
@@ -172,7 +_,20 @@
       return this.setBlock(p_180501_1_, p_180501_2_, p_180501_3_, 512);
    }
 
+   // CatServer start - fix bpo mod mixin injection exception
+   private boolean catserver$captureBlockState; // CatServer - creating in the method body will affect mixin injection, so use global instead
    public boolean setBlock(BlockPos p_241211_1_, BlockState p_241211_2_, int p_241211_3_, int p_241211_4_) {
+      // CraftBukkit start - tree generation
+      if (this.captureTreeGeneration) {
+         CapturedBlockState blockstate = capturedBlockStates.get(p_241211_1_);
+         if (blockstate == null) {
+            blockstate = CapturedBlockState.getTreeBlockState(this, p_241211_1_, p_241211_3_);
+            this.capturedBlockStates.put(p_241211_1_.immutable(), blockstate);
+         }
+         blockstate.setData(p_241211_2_);
+         return true;
+      }
+      // CraftBukkit end
       if (isOutsideBuildHeight(p_241211_1_)) {
          return false;
       } else if (!this.isClientSide && this.isDebug()) {
@@ -180,17 +_,67 @@
       } else {
          Chunk chunk = this.getChunkAt(p_241211_1_);
          Block block = p_241211_2_.getBlock();
-         BlockState blockstate = chunk.setBlockState(p_241211_1_, p_241211_2_, (p_241211_3_ & 64) != 0);
+         // CraftBukkit start - capture blockstates
+         if (this.captureBlockStates && !this.capturedBlockStates.containsKey(p_241211_1_)) {
+            CapturedBlockState blockstate = CapturedBlockState.getBlockState(this, p_241211_1_, p_241211_3_);
+            this.capturedBlockStates.put(p_241211_1_.immutable(), blockstate);
+            catserver$captureBlockState = true; // CatServer
+         }
+         // CraftBukkit end
+
+         p_241211_1_ = p_241211_1_.immutable(); // Forge - prevent mutable BlockPos leaks
+         net.minecraftforge.common.util.BlockSnapshot blockSnapshot = null;
+         if (this.captureBlockSnapshots && !this.isClientSide) {
+             blockSnapshot = net.minecraftforge.common.util.BlockSnapshot.create(this.dimension, this, p_241211_1_, p_241211_3_);
+             this.capturedBlockSnapshots.add(blockSnapshot);
+         }
+
+         BlockState old = getBlockState(p_241211_1_);
+         int oldLight = old.getLightValue(this, p_241211_1_);
+         int oldOpacity = old.getLightBlock(this, p_241211_1_);
+
+         chunk.catserver$doPlace = (p_241211_3_ & 1024) == 0; // CatServer
+         BlockState blockstate = chunk.setBlockState(p_241211_1_, p_241211_2_, (p_241211_3_ & 64) != 0); // CatServer
          if (blockstate == null) {
+            // CraftBukkit start - remove blockstate if failed (or the same)
+            if (this.captureBlockStates && catserver$captureBlockState) { // CatServer
+               this.capturedBlockStates.remove(p_241211_1_);
+            }
+            // CraftBukkit end
+            if (blockSnapshot != null) this.capturedBlockSnapshots.remove(blockSnapshot);
             return false;
          } else {
             BlockState blockstate1 = this.getBlockState(p_241211_1_);
-            if ((p_241211_3_ & 128) == 0 && blockstate1 != blockstate && (blockstate1.getLightBlock(this, p_241211_1_) != blockstate.getLightBlock(this, p_241211_1_) || blockstate1.getLightEmission() != blockstate.getLightEmission() || blockstate1.useShapeForLightOcclusion() || blockstate.useShapeForLightOcclusion())) {
+            if ((p_241211_3_ & 128) == 0 && blockstate1 != blockstate && (blockstate1.getLightBlock(this, p_241211_1_) != oldOpacity || blockstate1.getLightValue(this, p_241211_1_) != oldLight || blockstate1.useShapeForLightOcclusion() || blockstate.useShapeForLightOcclusion())) {
                this.getProfiler().push("queueCheckLight");
                this.getChunkSource().getLightEngine().checkBlock(p_241211_1_);
                this.getProfiler().pop();
             }
 
+            // CraftBukkit start
+            if (blockSnapshot == null && !this.captureBlockStates) {// Don't notify clients or update physics while capturing blockstates
+               // Modularize client and physic updates
+               // Spigot start
+               try {
+                  markAndNotifyBlock(p_241211_1_, chunk, blockstate, p_241211_2_, p_241211_3_, p_241211_4_);
+               } catch (StackOverflowError ex) {
+                  lastPhysicsProblem = new BlockPos(p_241211_1_);
+               }
+               // Spigot end
+            }
+            return true;
+         }
+      }
+   }
+   // CatServer end
+
+   // Split off from original setBlockState(BlockPos, BlockState, int, int) method in order to directly send client and physic updates
+   public void markAndNotifyBlock(BlockPos p_241211_1_, @Nullable Chunk chunk, BlockState blockstate, BlockState p_241211_2_, int p_241211_3_, int p_241211_4_)
+   {
+       Block block = p_241211_2_.getBlock();
+       BlockState blockstate1 = getBlockState(p_241211_1_);
+       {
+           {
             if (blockstate1 == p_241211_2_) {
                if (blockstate != blockstate1) {
                   this.setBlocksDirty(p_241211_1_, blockstate, blockstate1);
@@ -210,14 +_,24 @@
                if ((p_241211_3_ & 16) == 0 && p_241211_4_ > 0) {
                   int i = p_241211_3_ & -34;
                   blockstate.updateIndirectNeighbourShapes(this, p_241211_1_, i, p_241211_4_ - 1);
+
+                  // CraftBukkit start
+                  CraftWorld world = ((ServerWorld) this).getWorld();
+                  if (world != null) {
+                     BlockPhysicsEvent event = new BlockPhysicsEvent(world.getBlockAt(p_241211_1_.getX(), p_241211_1_.getY(), p_241211_1_.getZ()), CraftBlockData.fromData(p_241211_2_));
+                     this.getCBServer().getPluginManager().callEvent(event);
+                     if (event.isCancelled()) {
+                        return;
+                     }
+                  }
+                  // CraftBukkit end
+
                   p_241211_2_.updateNeighbourShapes(this, p_241211_1_, i, p_241211_4_ - 1);
                   p_241211_2_.updateIndirectNeighbourShapes(this, p_241211_1_, i, p_241211_4_ - 1);
                }
 
                this.onBlockStateChange(p_241211_1_, blockstate, blockstate1);
             }
-
-            return true;
          }
       }
    }
@@ -232,7 +_,7 @@
 
    public boolean destroyBlock(BlockPos p_241212_1_, boolean p_241212_2_, @Nullable Entity p_241212_3_, int p_241212_4_) {
       BlockState blockstate = this.getBlockState(p_241212_1_);
-      if (blockstate.isAir()) {
+      if (blockstate.isAir(this, p_241212_1_)) {
          return false;
       } else {
          FluidState fluidstate = this.getFluidState(p_241212_1_);
@@ -241,7 +_,7 @@
          }
 
          if (p_241212_2_) {
-            TileEntity tileentity = blockstate.getBlock().isEntityBlock() ? this.getBlockEntity(p_241212_1_) : null;
+            TileEntity tileentity = blockstate.hasTileEntity() ? this.getBlockEntity(p_241212_1_) : null;
             Block.dropResources(blockstate, this, p_241212_1_, tileentity, p_241212_3_, ItemStack.EMPTY);
          }
 
@@ -259,6 +_,9 @@
    }
 
    public void updateNeighborsAt(BlockPos p_195593_1_, Block p_195593_2_) {
+      if (captureBlockStates) { return; } // Paper - Cancel all physics during placement
+      if (net.minecraftforge.event.ForgeEventFactory.onNeighborNotify(this, p_195593_1_, this.getBlockState(p_195593_1_), java.util.EnumSet.allOf(Direction.class), false).isCanceled())
+         return;
       this.neighborChanged(p_195593_1_.west(), p_195593_2_, p_195593_1_);
       this.neighborChanged(p_195593_1_.east(), p_195593_2_, p_195593_1_);
       this.neighborChanged(p_195593_1_.below(), p_195593_2_, p_195593_1_);
@@ -268,6 +_,11 @@
    }
 
    public void updateNeighborsAtExceptFromFacing(BlockPos p_175695_1_, Block p_175695_2_, Direction p_175695_3_) {
+      java.util.EnumSet<Direction> directions = java.util.EnumSet.allOf(Direction.class);
+      directions.remove(p_175695_3_);
+      if (net.minecraftforge.event.ForgeEventFactory.onNeighborNotify(this, p_175695_1_, this.getBlockState(p_175695_1_), directions, false).isCanceled())
+         return;
+
       if (p_175695_3_ != Direction.WEST) {
          this.neighborChanged(p_175695_1_.west(), p_175695_2_, p_175695_1_);
       }
@@ -299,15 +_,29 @@
          BlockState blockstate = this.getBlockState(p_190524_1_);
 
          try {
+            // CraftBukkit start
+            CraftWorld world = ((ServerWorld) this).getWorld();
+            if (world != null) {
+               BlockPhysicsEvent event = new BlockPhysicsEvent(world.getBlockAt(p_190524_1_.getX(), p_190524_1_.getY(), p_190524_1_.getZ()), CraftBlockData.fromData(blockstate), world.getBlockAt(p_190524_3_.getX(), p_190524_3_.getY(), p_190524_3_.getZ()));
+               this.getCBServer().getPluginManager().callEvent(event);
+               if (event.isCancelled()) {
+                  return;
+               }
+            }
+            // CraftBukkit end
             blockstate.neighborChanged(this, p_190524_1_, p_190524_2_, p_190524_3_, false);
+            // Spigot Start
+         } catch (StackOverflowError ex) {
+            lastPhysicsProblem = new BlockPos(p_190524_1_);
+            // Spigot End
          } catch (Throwable throwable) {
             CrashReport crashreport = CrashReport.forThrowable(throwable, "Exception while updating neighbours");
             CrashReportCategory crashreportcategory = crashreport.addCategory("Block being updated");
             crashreportcategory.setDetail("Source block type", () -> {
                try {
-                  return String.format("ID #%s (%s // %s)", Registry.BLOCK.getKey(p_190524_2_), p_190524_2_.getDescriptionId(), p_190524_2_.getClass().getCanonicalName());
+                  return String.format("ID #%s (%s // %s)", p_190524_2_.getRegistryName(), p_190524_2_.getDescriptionId(), p_190524_2_.getClass().getCanonicalName());
                } catch (Throwable throwable1) {
-                  return "ID #" + Registry.BLOCK.getKey(p_190524_2_);
+                  return "ID #" + p_190524_2_.getRegistryName();
                }
             });
             CrashReportCategory.populateBlockDetails(crashreportcategory, p_190524_1_, blockstate);
@@ -336,6 +_,14 @@
    }
 
    public BlockState getBlockState(BlockPos p_180495_1_) {
+      // CraftBukkit start - tree generation
+      if (captureTreeGeneration) {
+         CapturedBlockState previous = capturedBlockStates.get(p_180495_1_);
+         if (previous != null) {
+            return previous.getHandle();
+         }
+      }
+      // CraftBukkit end
       if (isOutsideBuildHeight(p_180495_1_)) {
          return Blocks.VOID_AIR.defaultBlockState();
       } else {
@@ -375,7 +_,6 @@
    public void addParticle(IParticleData p_195594_1_, double p_195594_2_, double p_195594_4_, double p_195594_6_, double p_195594_8_, double p_195594_10_, double p_195594_12_) {
    }
 
-   @OnlyIn(Dist.CLIENT)
    public void addParticle(IParticleData p_195590_1_, boolean p_195590_2_, double p_195590_3_, double p_195590_5_, double p_195590_7_, double p_195590_9_, double p_195590_11_, double p_195590_13_) {
    }
 
@@ -391,10 +_,12 @@
    }
 
    public boolean addBlockEntity(TileEntity p_175700_1_) {
+      if (p_175700_1_.getLevel() != this) p_175700_1_.setLevelAndPosition(this, p_175700_1_.getBlockPos()); // Forge - set the world early as vanilla doesn't set it until next tick
       if (this.updatingBlockEntities) {
          LOGGER.error("Adding block entity while ticking: {} @ {}", () -> {
             return Registry.BLOCK_ENTITY_TYPE.getKey(p_175700_1_.getType());
          }, p_175700_1_::getBlockPos);
+         return pendingBlockEntities.add(p_175700_1_); // Forge: wait to add new TE if we're currently processing existing ones
       }
 
       boolean flag = this.blockEntityList.add(p_175700_1_);
@@ -402,6 +_,8 @@
          this.tickableBlockEntities.add(p_175700_1_);
       }
 
+      p_175700_1_.onLoad();
+
       if (this.isClientSide) {
          BlockPos blockpos = p_175700_1_.getBlockPos();
          BlockState blockstate = this.getBlockState(blockpos);
@@ -413,6 +_,7 @@
 
    public void addAllPendingBlockEntities(Collection<TileEntity> p_147448_1_) {
       if (this.updatingBlockEntities) {
+         p_147448_1_.stream().filter(te -> te.getLevel() != this).forEach(te -> te.setLevelAndPosition(this, te.getBlockPos())); // Forge - set the world early as vanilla doesn't set it until next tick
          this.pendingBlockEntities.addAll(p_147448_1_);
       } else {
          for(TileEntity tileentity : p_147448_1_) {
@@ -425,64 +_,110 @@
    public void tickBlockEntities() {
       IProfiler iprofiler = this.getProfiler();
       iprofiler.push("blockEntities");
+      timings.tileEntityTick.startTiming(); // Spigot
+      this.updatingBlockEntities = true;// Forge: Move above remove to prevent CMEs
       if (!this.blockEntitiesToUnload.isEmpty()) {
+         this.blockEntitiesToUnload.forEach(e -> e.onChunkUnloaded());
          this.tickableBlockEntities.removeAll(this.blockEntitiesToUnload);
-         this.blockEntityList.removeAll(this.blockEntitiesToUnload);
+         // Paper start - Use alternate implementation with faster contains
+         java.util.Set<TileEntity> toRemove = java.util.Collections.newSetFromMap(new java.util.IdentityHashMap<>());
+         toRemove.addAll(blockEntitiesToUnload);
+         this.blockEntityList.removeAll(toRemove);
+         // Paper end
          this.blockEntitiesToUnload.clear();
       }
 
-      this.updatingBlockEntities = true;
-      Iterator<TileEntity> iterator = this.tickableBlockEntities.iterator();
-
-      while(iterator.hasNext()) {
-         TileEntity tileentity = iterator.next();
+      // Spigot start
+      int tilesThisCycle = 0;
+      for (tileLimiter.initTick();
+          tilesThisCycle <  tickableBlockEntities.size() && (tilesThisCycle % 10 != 0 || tileLimiter.shouldContinue());
+          tileTickPosition++, tilesThisCycle++) {
+         tileTickPosition = (tileTickPosition < tickableBlockEntities.size()) ? tileTickPosition : 0;
+         TileEntity tileentity = (TileEntity) this.tickableBlockEntities.get(tileTickPosition);
+         // Spigot start
+         if (tileentity == null) {
+            getCBServer().getLogger().severe("Spigot has detected a null entity and has removed it, preventing a crash");
+            tilesThisCycle--;
+            this.tickableBlockEntities.remove(tileTickPosition--);
+            continue;
+         }
+         // Spigot end
          if (!tileentity.isRemoved() && tileentity.hasLevel()) {
             BlockPos blockpos = tileentity.getBlockPos();
             if (this.getChunkSource().isTickingChunk(blockpos) && this.getWorldBorder().isWithinBounds(blockpos)) {
                try {
+                  net.minecraftforge.server.timings.TimeTracker.TILE_ENTITY_UPDATE.trackStart(tileentity);
                   iprofiler.push(() -> {
-                     return String.valueOf((Object)TileEntityType.getKey(tileentity.getType()));
+                     return String.valueOf(tileentity.getType().getRegistryName());
                   });
+                  tileentity.tickTimer.startTiming(); // Spigot
+                  catserver.server.command.internal.CommandChunkStats.onTickStart();
                   if (tileentity.getType().isValid(this.getBlockState(blockpos).getBlock())) {
                      ((ITickableTileEntity)tileentity).tick();
                   } else {
                      tileentity.logInvalidState();
                   }
+                  catserver.server.command.internal.CommandChunkStats.onTickEnd(this, tileentity.getBlockPos());
 
                   iprofiler.pop();
                } catch (Throwable throwable) {
                   CrashReport crashreport = CrashReport.forThrowable(throwable, "Ticking block entity");
                   CrashReportCategory crashreportcategory = crashreport.addCategory("Block entity being ticked");
                   tileentity.fillCrashReportCategory(crashreportcategory);
+                  if (net.minecraftforge.common.ForgeConfig.SERVER.removeErroringTileEntities.get()) {
+                     LogManager.getLogger().fatal("{}", crashreport.getFriendlyReport());
+                     tileentity.setRemoved();
+                     this.removeBlockEntity(tileentity.getBlockPos());
+                  } else
                   throw new ReportedException(crashreport);
                }
+               finally {
+                  tileentity.tickTimer.stopTiming(); // Spigot
+                  net.minecraftforge.server.timings.TimeTracker.TILE_ENTITY_UPDATE.trackEnd(tileentity);
+               }
             }
          }
 
          if (tileentity.isRemoved()) {
-            iterator.remove();
+            // Spigot start
+            tilesThisCycle--;
+            this.tickableBlockEntities.remove(tileTickPosition--);
+            // Spigot end
             this.blockEntityList.remove(tileentity);
             if (this.hasChunkAt(tileentity.getBlockPos())) {
-               this.getChunkAt(tileentity.getBlockPos()).removeBlockEntity(tileentity.getBlockPos());
+               //Forge: Bugfix: If we set the tile entity it immediately sets it in the chunk, so we could be desyned
+               Chunk chunk = this.getChunkAt(tileentity.getBlockPos());
+               if (chunk.getBlockEntity(tileentity.getBlockPos(), Chunk.CreateEntityType.CHECK) == tileentity)
+                  chunk.removeBlockEntity(tileentity.getBlockPos());
             }
          }
       }
 
+      timings.tileEntityTick.stopTiming(); // Spigot
+      timings.tileEntityPending.startTiming(); // Spigot
       this.updatingBlockEntities = false;
       iprofiler.popPush("pendingBlockEntities");
       if (!this.pendingBlockEntities.isEmpty()) {
          for(int i = 0; i < this.pendingBlockEntities.size(); ++i) {
             TileEntity tileentity1 = this.pendingBlockEntities.get(i);
             if (!tileentity1.isRemoved()) {
-               if (!this.blockEntityList.contains(tileentity1)) {
-                  this.addBlockEntity(tileentity1);
+                /* CraftBukkit start - Order matters, moved down
+               if (!this.loadedTileEntityList.contains(tileentity1)) {
+                  this.addTileEntity(tileentity1);
                }
+               // CraftBukkit end */
 
                if (this.hasChunkAt(tileentity1.getBlockPos())) {
                   Chunk chunk = this.getChunkAt(tileentity1.getBlockPos());
                   BlockState blockstate = chunk.getBlockState(tileentity1.getBlockPos());
                   chunk.setBlockEntity(tileentity1.getBlockPos(), tileentity1);
                   this.sendBlockUpdated(tileentity1.getBlockPos(), blockstate, blockstate, 3);
+                  // CraftBukkit start
+                  // From above, don't screw this up - SPIGOT-1746
+                  if (!this.blockEntityList.contains(tileentity1)) {
+                     this.addBlockEntity(tileentity1);
+                  }
+                  // CraftBukkit end
                }
             }
          }
@@ -490,22 +_,31 @@
          this.pendingBlockEntities.clear();
       }
 
+      timings.tileEntityPending.stopTiming(); // Spigot
       iprofiler.pop();
+      spigotConfig.currentPrimedTnt = 0; // Spigot
    }
 
    public void guardEntityTick(Consumer<Entity> p_217390_1_, Entity p_217390_2_) {
       try {
+         net.minecraftforge.server.timings.TimeTracker.ENTITY_UPDATE.trackStart(p_217390_2_);
+         SpigotTimings.tickEntityTimer.startTiming(); // Spigot
+         catserver.server.command.internal.CommandChunkStats.onTickStart();
          p_217390_1_.accept(p_217390_2_);
+         catserver.server.command.internal.CommandChunkStats.onTickEnd(this, p_217390_2_.blockPosition());
+         SpigotTimings.tickEntityTimer.stopTiming(); // Spigot
       } catch (Throwable throwable) {
          CrashReport crashreport = CrashReport.forThrowable(throwable, "Ticking entity");
          CrashReportCategory crashreportcategory = crashreport.addCategory("Entity being ticked");
          p_217390_2_.fillCrashReportCategory(crashreportcategory);
          throw new ReportedException(crashreport);
+      } finally {
+         net.minecraftforge.server.timings.TimeTracker.ENTITY_UPDATE.trackEnd(p_217390_2_);
       }
    }
 
    public Explosion explode(@Nullable Entity p_217385_1_, double p_217385_2_, double p_217385_4_, double p_217385_6_, float p_217385_8_, Explosion.Mode p_217385_9_) {
-      return this.explode(p_217385_1_, (DamageSource)null, (ExplosionContext)null, p_217385_2_, p_217385_4_, p_217385_6_, p_217385_8_, false, p_217385_9_);
+      return this.explode(p_217385_1_, (DamageSource)null, (ExplosionContext)null, p_217385_2_, p_217385_4_, p_217385_6_, p_217385_8_, this.pehkuiExplosionFire, p_217385_9_);
    }
 
    public Explosion explode(@Nullable Entity p_217398_1_, double p_217398_2_, double p_217398_4_, double p_217398_6_, float p_217398_8_, boolean p_217398_9_, Explosion.Mode p_217398_10_) {
@@ -514,6 +_,7 @@
 
    public Explosion explode(@Nullable Entity p_230546_1_, @Nullable DamageSource p_230546_2_, @Nullable ExplosionContext p_230546_3_, double p_230546_4_, double p_230546_6_, double p_230546_8_, float p_230546_10_, boolean p_230546_11_, Explosion.Mode p_230546_12_) {
       Explosion explosion = new Explosion(this, p_230546_1_, p_230546_2_, p_230546_3_, p_230546_4_, p_230546_6_, p_230546_8_, p_230546_10_, p_230546_11_, p_230546_12_);
+      if (net.minecraftforge.event.ForgeEventFactory.onExplosionStart(this, explosion)) return explosion;
       explosion.explode();
       explosion.finalizeExplosion(true);
       return explosion;
@@ -523,24 +_,48 @@
       return this.getChunkSource().gatherStats();
    }
 
+   // TODO : LoliServer - Compatible with mythicmobs
+   @Nullable
+   public Chunk getChunkIfLoaded(int x, int z) { // Overridden in WorldServer for ABI compat which has final
+      return ((ServerWorld) this).getChunkSource().getChunk(x, z, false);
+   }
+
+   @Nullable
+   public final Chunk getChunkIfLoaded(BlockPos blockposition) {
+      return ((ServerWorld) this).getChunkSource().getChunk(blockposition.getX() >> 4, blockposition.getZ() >> 4, false);
+   }
+   // LoliServer TODO
+
    @Nullable
    public TileEntity getBlockEntity(BlockPos p_175625_1_) {
-      if (isOutsideBuildHeight(p_175625_1_)) {
+      // CraftBukkit start
+      return getTileEntity(p_175625_1_, true);
+   }
+
+   public TileEntity getTileEntity(BlockPos pos, boolean validate) {
+      // CraftBukkit end
+      if (isOutsideBuildHeight(pos)) {
          return null;
       } else if (!this.isClientSide && Thread.currentThread() != this.thread) {
          return null;
       } else {
+         // CraftBukkit start
+         if (capturedTileEntities.containsKey(pos)) {
+            return capturedTileEntities.get(pos);
+         }
+         // CraftBukkit end
+
          TileEntity tileentity = null;
          if (this.updatingBlockEntities) {
-            tileentity = this.getPendingBlockEntityAt(p_175625_1_);
-         }
-
-         if (tileentity == null) {
-            tileentity = this.getChunkAt(p_175625_1_).getBlockEntity(p_175625_1_, Chunk.CreateEntityType.IMMEDIATE);
-         }
-
-         if (tileentity == null) {
-            tileentity = this.getPendingBlockEntityAt(p_175625_1_);
+            tileentity = this.getPendingBlockEntityAt(pos);
+         }
+
+         if (tileentity == null) {
+            tileentity = this.getChunkAt(pos).getBlockEntity(pos, Chunk.CreateEntityType.IMMEDIATE);
+         }
+
+         if (tileentity == null) {
+            tileentity = this.getPendingBlockEntityAt(pos);
          }
 
          return tileentity;
@@ -561,7 +_,15 @@
 
    public void setBlockEntity(BlockPos p_175690_1_, @Nullable TileEntity p_175690_2_) {
       if (!isOutsideBuildHeight(p_175690_1_)) {
+         p_175690_1_ = p_175690_1_.immutable(); // Forge - prevent mutable BlockPos leaks
          if (p_175690_2_ != null && !p_175690_2_.isRemoved()) {
+            // CraftBukkit start
+            if (captureBlockStates) {
+               p_175690_2_.setLevelAndPosition(this, p_175690_1_);
+               capturedTileEntities.put(p_175690_1_.immutable(), p_175690_2_);
+               return;
+            }
+            // CraftBukkit end
             if (this.updatingBlockEntities) {
                p_175690_2_.setLevelAndPosition(this, p_175690_1_);
                Iterator<TileEntity> iterator = this.pendingBlockEntities.iterator();
@@ -576,7 +_,8 @@
 
                this.pendingBlockEntities.add(p_175690_2_);
             } else {
-               this.getChunkAt(p_175690_1_).setBlockEntity(p_175690_1_, p_175690_2_);
+               Chunk chunk = this.getChunkAt(p_175690_1_);
+               if (chunk != null) chunk.setBlockEntity(p_175690_1_, p_175690_2_);
                this.addBlockEntity(p_175690_2_);
             }
          }
@@ -585,10 +_,12 @@
    }
 
    public void removeBlockEntity(BlockPos p_175713_1_) {
-      TileEntity tileentity = this.getBlockEntity(p_175713_1_);
+      TileEntity tileentity = this.getTileEntity(p_175713_1_, false); // CraftBukkit
       if (tileentity != null && this.updatingBlockEntities) {
          tileentity.setRemoved();
          this.pendingBlockEntities.remove(tileentity);
+         if (!(tileentity instanceof ITickableTileEntity)) //Forge: If they are not tickable they wont be removed in the update loop.
+            this.blockEntityList.remove(tileentity);
       } else {
          if (tileentity != null) {
             this.pendingBlockEntities.remove(tileentity);
@@ -598,7 +_,7 @@
 
          this.getChunkAt(p_175713_1_).removeBlockEntity(p_175713_1_);
       }
-
+      this.updateNeighbourForOutputSignal(p_175713_1_, getBlockState(p_175713_1_).getBlock()); //Notify neighbors of changes
    }
 
    public boolean isLoaded(BlockPos p_195588_1_) {
@@ -651,10 +_,10 @@
    public List<Entity> getEntities(@Nullable Entity p_175674_1_, AxisAlignedBB p_175674_2_, @Nullable Predicate<? super Entity> p_175674_3_) {
       this.getProfiler().incrementCounter("getEntities");
       List<Entity> list = Lists.newArrayList();
-      int i = MathHelper.floor((p_175674_2_.minX - 2.0D) / 16.0D);
-      int j = MathHelper.floor((p_175674_2_.maxX + 2.0D) / 16.0D);
-      int k = MathHelper.floor((p_175674_2_.minZ - 2.0D) / 16.0D);
-      int l = MathHelper.floor((p_175674_2_.maxZ + 2.0D) / 16.0D);
+      int i = MathHelper.floor((p_175674_2_.minX - getMaxEntityRadius()) / 16.0D);
+      int j = MathHelper.floor((p_175674_2_.maxX + getMaxEntityRadius()) / 16.0D);
+      int k = MathHelper.floor((p_175674_2_.minZ - getMaxEntityRadius()) / 16.0D);
+      int l = MathHelper.floor((p_175674_2_.maxZ + getMaxEntityRadius()) / 16.0D);
       AbstractChunkProvider abstractchunkprovider = this.getChunkSource();
 
       for(int i1 = i; i1 <= j; ++i1) {
@@ -665,16 +_,21 @@
             }
          }
       }
+      for (net.minecraftforge.entity.PartEntity<?> p : this.getPartEntities()) {
+         if (p != p_175674_1_ && p.getBoundingBox().intersects(p_175674_2_) && (p_175674_3_ == null || p_175674_3_.test(p))) {
+            list.add(p);
+         }
+      }
 
       return list;
    }
 
    public <T extends Entity> List<T> getEntities(@Nullable EntityType<T> p_217394_1_, AxisAlignedBB p_217394_2_, Predicate<? super T> p_217394_3_) {
       this.getProfiler().incrementCounter("getEntities");
-      int i = MathHelper.floor((p_217394_2_.minX - 2.0D) / 16.0D);
-      int j = MathHelper.ceil((p_217394_2_.maxX + 2.0D) / 16.0D);
-      int k = MathHelper.floor((p_217394_2_.minZ - 2.0D) / 16.0D);
-      int l = MathHelper.ceil((p_217394_2_.maxZ + 2.0D) / 16.0D);
+      int i = MathHelper.floor((p_217394_2_.minX - getMaxEntityRadius()) / 16.0D);
+      int j = MathHelper.ceil((p_217394_2_.maxX + getMaxEntityRadius()) / 16.0D);
+      int k = MathHelper.floor((p_217394_2_.minZ - getMaxEntityRadius()) / 16.0D);
+      int l = MathHelper.ceil((p_217394_2_.maxZ + getMaxEntityRadius()) / 16.0D);
       List<T> list = Lists.newArrayList();
 
       for(int i1 = i; i1 < j; ++i1) {
@@ -691,10 +_,10 @@
 
    public <T extends Entity> List<T> getEntitiesOfClass(Class<? extends T> p_175647_1_, AxisAlignedBB p_175647_2_, @Nullable Predicate<? super T> p_175647_3_) {
       this.getProfiler().incrementCounter("getEntities");
-      int i = MathHelper.floor((p_175647_2_.minX - 2.0D) / 16.0D);
-      int j = MathHelper.ceil((p_175647_2_.maxX + 2.0D) / 16.0D);
-      int k = MathHelper.floor((p_175647_2_.minZ - 2.0D) / 16.0D);
-      int l = MathHelper.ceil((p_175647_2_.maxZ + 2.0D) / 16.0D);
+      int i = MathHelper.floor((p_175647_2_.minX - getMaxEntityRadius()) / 16.0D);
+      int j = MathHelper.ceil((p_175647_2_.maxX + getMaxEntityRadius()) / 16.0D);
+      int k = MathHelper.floor((p_175647_2_.minZ - getMaxEntityRadius()) / 16.0D);
+      int l = MathHelper.ceil((p_175647_2_.maxZ + getMaxEntityRadius()) / 16.0D);
       List<T> list = Lists.newArrayList();
       AbstractChunkProvider abstractchunkprovider = this.getChunkSource();
 
@@ -712,10 +_,10 @@
 
    public <T extends Entity> List<T> getLoadedEntitiesOfClass(Class<? extends T> p_225316_1_, AxisAlignedBB p_225316_2_, @Nullable Predicate<? super T> p_225316_3_) {
       this.getProfiler().incrementCounter("getLoadedEntities");
-      int i = MathHelper.floor((p_225316_2_.minX - 2.0D) / 16.0D);
-      int j = MathHelper.ceil((p_225316_2_.maxX + 2.0D) / 16.0D);
-      int k = MathHelper.floor((p_225316_2_.minZ - 2.0D) / 16.0D);
-      int l = MathHelper.ceil((p_225316_2_.maxZ + 2.0D) / 16.0D);
+      int i = MathHelper.floor((p_225316_2_.minX - getMaxEntityRadius()) / 16.0D);
+      int j = MathHelper.ceil((p_225316_2_.maxX + getMaxEntityRadius()) / 16.0D);
+      int k = MathHelper.floor((p_225316_2_.minZ - getMaxEntityRadius()) / 16.0D);
+      int l = MathHelper.ceil((p_225316_2_.maxZ + getMaxEntityRadius()) / 16.0D);
       List<T> list = Lists.newArrayList();
       AbstractChunkProvider abstractchunkprovider = this.getChunkSource();
 
@@ -739,6 +_,7 @@
          this.getChunkAt(p_175646_1_).markUnsaved();
       }
 
+      this.updateNeighbourForOutputSignal(p_175646_1_, getBlockState(p_175646_1_).getBlock()); //Notify neighbors of changes
    }
 
    public int getSeaLevel() {
@@ -783,7 +_,7 @@
    public int getSignal(BlockPos p_175651_1_, Direction p_175651_2_) {
       BlockState blockstate = this.getBlockState(p_175651_1_);
       int i = blockstate.getSignal(this, p_175651_1_, p_175651_2_);
-      return blockstate.isRedstoneConductor(this, p_175651_1_) ? Math.max(i, this.getDirectSignalTo(p_175651_1_)) : i;
+      return blockstate.shouldCheckWeakPower(this, p_175651_1_, p_175651_2_) ? Math.max(i, this.getDirectSignalTo(p_175651_1_)) : i;
    }
 
    public boolean hasNeighborSignal(BlockPos p_175640_1_) {
@@ -938,16 +_,15 @@
    public abstract Scoreboard getScoreboard();
 
    public void updateNeighbourForOutputSignal(BlockPos p_175666_1_, Block p_175666_2_) {
-      for(Direction direction : Direction.Plane.HORIZONTAL) {
+      for(Direction direction : Direction.values()) {
          BlockPos blockpos = p_175666_1_.relative(direction);
          if (this.hasChunkAt(blockpos)) {
             BlockState blockstate = this.getBlockState(blockpos);
-            if (blockstate.is(Blocks.COMPARATOR)) {
-               blockstate.neighborChanged(this, blockpos, p_175666_2_, p_175666_1_, false);
-            } else if (blockstate.isRedstoneConductor(this, blockpos)) {
+            blockstate.onNeighborChange(this, blockpos, p_175666_1_);
+            if (blockstate.isRedstoneConductor(this, blockpos)) {
                blockpos = blockpos.relative(direction);
                blockstate = this.getBlockState(blockpos);
-               if (blockstate.is(Blocks.COMPARATOR)) {
+               if (blockstate.getWeakChanges(this, blockpos)) {
                   blockstate.neighborChanged(this, blockpos, p_175666_2_, p_175666_1_, false);
                }
             }
@@ -990,6 +_,12 @@
       return this.dimension;
    }
 
+   //LoliServer start
+   public RegistryKey<World> dimension1() {
+      return this.dimension;
+   }
+   //LoliServer end
+
    public Random getRandom() {
       return this.random;
    }
@@ -1024,7 +_,25 @@
       return this.biomeManager;
    }
 
+   private double maxEntityRadius = 2.0D;
+   @Override
+   public double getMaxEntityRadius() {
+      return maxEntityRadius;
+   }
+   @Override
+   public double increaseMaxEntityRadius(double value) {
+      if (value > maxEntityRadius)
+         maxEntityRadius = value;
+      return maxEntityRadius;
+   }
+
    public final boolean isDebug() {
       return this.isDebug;
    }
+
+   // CraftBukkit - start
+   public void notifyAndUpdatePhysics(BlockPos position, Chunk o, BlockState oldBlock, BlockState newBlock, BlockState actualBlock, int flag, int i) {
+      markAndNotifyBlock(position, o, oldBlock, newBlock, flag, i);
+   }
+    // CraftBukkit - stop
 }
