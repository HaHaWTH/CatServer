--- a/net/minecraft/world/storage/MapData.java
+++ b/net/minecraft/world/storage/MapData.java
@@ -2,18 +_,24 @@
 
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
+import com.mojang.serialization.DataResult;
 import com.mojang.serialization.Dynamic;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
+import java.util.UUID;
 import javax.annotation.Nullable;
 import net.minecraft.entity.item.ItemFrameEntity;
 import net.minecraft.entity.player.PlayerEntity;
 import net.minecraft.item.FilledMapItem;
 import net.minecraft.item.ItemStack;
 import net.minecraft.nbt.CompoundNBT;
+import net.minecraft.nbt.INBT;
 import net.minecraft.nbt.ListNBT;
 import net.minecraft.nbt.NBTDynamicOps;
+import net.minecraft.nbt.NumberNBT;
+import net.minecraft.nbt.StringNBT;
 import net.minecraft.network.IPacket;
 import net.minecraft.network.play.server.SMapDataPacket;
 import net.minecraft.util.RegistryKey;
@@ -27,6 +_,10 @@
 import net.minecraft.world.World;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.bukkit.craftbukkit.v1_16_R3.CraftServer;
+import org.bukkit.craftbukkit.v1_16_R3.CraftWorld;
+import org.bukkit.craftbukkit.v1_16_R3.map.CraftMapView;
+import org.bukkit.craftbukkit.v1_16_R3.util.CraftChatMessage;
 
 public class MapData extends WorldSavedData {
    private static final Logger LOGGER = LogManager.getLogger();
@@ -43,9 +_,21 @@
    private final Map<String, MapBanner> bannerMarkers = Maps.newHashMap();
    public final Map<String, MapDecoration> decorations = Maps.newLinkedHashMap();
    private final Map<String, MapFrame> frameMarkers = Maps.newHashMap();
+   private org.bukkit.craftbukkit.v1_16_R3.map.RenderData vanillaRender = new org.bukkit.craftbukkit.v1_16_R3.map.RenderData(); // Paper
+
+   // CraftBukkit start
+   public final CraftMapView mapView;
+   private CraftServer server;
+   private UUID uniqueId = null;
+   // CraftBukkit end
 
    public MapData(String p_i2140_1_) {
       super(p_i2140_1_);
+      // CraftBukkit start
+      mapView = new CraftMapView(this);
+      server = (CraftServer) org.bukkit.Bukkit.getServer();
+      vanillaRender.buffer = colors;
+      // CraftBukkit end
    }
 
    public void setProperties(int p_237241_1_, int p_237241_2_, int p_237241_3_, boolean p_237241_4_, boolean p_237241_5_, RegistryKey<World> p_237241_6_) {
@@ -66,8 +_,45 @@
    }
 
    public void load(CompoundNBT p_76184_1_) {
-      this.dimension = DimensionType.parseLegacy(new Dynamic<>(NBTDynamicOps.INSTANCE, p_76184_1_.get("dimension"))).resultOrPartial(LOGGER::error).orElseThrow(() -> {
-         return new IllegalArgumentException("Invalid map dimension: " + p_76184_1_.get("dimension"));
+      // Paper start - fix "Not a string" spam
+      INBT dimension = p_76184_1_.get("dimension");
+      if (dimension instanceof NumberNBT && ((NumberNBT)dimension).getAsInt() >= 10) {
+         final long least = p_76184_1_.getLong("UUIDLeast");
+         final long most = p_76184_1_.getLong("UUIDMost");
+         if (least != 0L && most != 0L) {
+            this.uniqueId = new UUID(most, least);
+            final CraftWorld world = (CraftWorld)this.server.getWorld(this.uniqueId);
+            if (world != null) {
+               dimension = StringNBT.valueOf("minecaft:" + world.getName().toLowerCase(Locale.ENGLISH));
+            }
+            else {
+               dimension = StringNBT.valueOf("bukkit:_invalidworld_");
+            }
+         }
+         else {
+            dimension = StringNBT.valueOf("bukkit:_invalidworld_");
+         }
+      }
+      // Paper end - fix "Not a string" spam
+      // CraftBukkit start
+      DataResult<RegistryKey<World>> dataresult = DimensionType.parseLegacy(new Dynamic(NBTDynamicOps.INSTANCE, p_76184_1_.get("dimension")));
+      this.dimension = (RegistryKey) dataresult.resultOrPartial(LOGGER::error).orElseGet(() -> {
+         long least = p_76184_1_.getLong("UUIDLeast");
+         long most = p_76184_1_.getLong("UUIDMost");
+         if (least != 0L && most != 0L) {
+            this.uniqueId = new UUID(most, least);
+            CraftWorld world = (CraftWorld) server.getWorld(this.uniqueId);
+            // Check if the stored world details are correct.
+            if (world == null) {
+            /* All Maps which do not have their valid world loaded are set to a dimension which hopefully won't be reached.
+               This is to prevent them being corrupted with the wrong map data. */
+               // PAIL: Use Vanilla exception handling for now
+            } else {
+               return world.getHandle().dimension();
+            }
+         }
+         throw new IllegalArgumentException("Invalid map dimension: " + p_76184_1_.get("dimension"));
+         // CraftBukkit end
       });
       this.x = p_76184_1_.getInt("xCenter");
       this.z = p_76184_1_.getInt("zCenter");
@@ -87,6 +_,7 @@
          this.bannerMarkers.put(mapbanner.getId(), mapbanner);
          this.addDecoration(mapbanner.getDecoration(), (IWorld)null, mapbanner.getId(), (double)mapbanner.getPos().getX(), (double)mapbanner.getPos().getZ(), 180.0D, mapbanner.getName());
       }
+      this.vanillaRender.buffer = colors; // Paper
 
       ListNBT listnbt1 = p_76184_1_.getList("frames", 10);
 
@@ -102,6 +_,27 @@
       ResourceLocation.CODEC.encodeStart(NBTDynamicOps.INSTANCE, this.dimension.location()).resultOrPartial(LOGGER::error).ifPresent((p_237242_1_) -> {
          p_189551_1_.put("dimension", p_237242_1_);
       });
+
+      // CraftBukkit start
+      if (true) {
+         if (this.uniqueId == null) {
+            for (org.bukkit.World world : server.getWorlds()) {
+               CraftWorld cWorld = (CraftWorld) world;
+               if (cWorld.getHandle().dimension() == this.dimension) {
+                  this.uniqueId = cWorld.getUID();
+                  break;
+               }
+            }
+         }
+    /* Perform a second check to see if a matching world was found, this is a necessary
+       change incase Maps are forcefully unlinked from a World and lack a UID.*/
+         if (this.uniqueId != null) {
+            p_189551_1_.putLong("UUIDLeast", this.uniqueId.getLeastSignificantBits());
+            p_189551_1_.putLong("UUIDMost", this.uniqueId.getMostSignificantBits());
+         }
+      }
+      // CraftBukkit end
+
       p_189551_1_.putInt("xCenter", this.x);
       p_189551_1_.putInt("zCenter", this.z);
       p_189551_1_.putByte("scale", this.scale);
@@ -136,6 +_,7 @@
       this.setDirty();
    }
 
+   public void updateSeenPlayers(PlayerEntity entityhuman, ItemStack itemstack) { this.tickCarriedBy(entityhuman, itemstack); } // Paper - OBFHELPER
    public void tickCarriedBy(PlayerEntity p_76191_1_, ItemStack p_76191_2_) {
       if (!this.carriedByPlayers.containsKey(p_76191_1_)) {
          MapData.MapInfo mapdata$mapinfo = new MapData.MapInfo(p_76191_1_);
@@ -348,6 +_,22 @@
    }
 
    public class MapInfo {
+
+      // Paper start
+      private void addSeenPlayers(java.util.Collection<MapDecoration> icons) {
+         org.bukkit.entity.Player player = (org.bukkit.entity.Player) this.player.getBukkitEntity();
+         MapData.this.decorations.forEach((name, mapIcon) -> {
+            // If this cursor is for a player check visibility with vanish system
+            org.bukkit.entity.Player other = org.bukkit.Bukkit.getPlayerExact(name); // Spigot
+            if (other == null || player.canSee(other)) {
+               icons.add(mapIcon);
+            }
+         });
+      }
+      private boolean shouldUseVanillaMap() {
+         return mapView.getRenderers().size() == 1 && mapView.getRenderers().get(0).getClass() == org.bukkit.craftbukkit.v1_16_R3.map.CraftMapRenderer.class;
+      }
+      // Paper end
       public final PlayerEntity player;
       private boolean dirtyData = true;
       private int minDirtyX;
@@ -363,12 +_,26 @@
 
       @Nullable
       public IPacket<?> nextUpdatePacket(ItemStack p_176101_1_) {
+         // CraftBukkit start
+         if (!this.dirtyData && this.tick % 5 != 0) { this.tick++; return null; } // Paper - this won't end up sending, so don't render it!
+         boolean vanillaMaps = shouldUseVanillaMap(); // Paper
+         org.bukkit.craftbukkit.v1_16_R3.map.RenderData render = !vanillaMaps ? MapData.this.mapView.render((org.bukkit.craftbukkit.v1_16_R3.entity.CraftPlayer) this.player.getBukkitEntity()) : MapData.this.vanillaRender; // CraftBukkit // Paper
+
+         java.util.Collection<MapDecoration> icons = new java.util.ArrayList<MapDecoration>();
+         if (vanillaMaps) addSeenPlayers(icons); // Paper
+         for ( org.bukkit.map.MapCursor cursor : render.cursors) {
+            if (cursor.isVisible()) {
+               icons.add(new MapDecoration(MapDecoration.Type.byIcon(cursor.getRawType()), cursor.getX(), cursor.getY(), cursor.getDirection(), CraftChatMessage.fromStringOrNull(cursor.getCaption())));
+            }
+         }
+
          if (this.dirtyData) {
             this.dirtyData = false;
-            return new SMapDataPacket(FilledMapItem.getMapId(p_176101_1_), MapData.this.scale, MapData.this.trackingPosition, MapData.this.locked, MapData.this.decorations.values(), MapData.this.colors, this.minDirtyX, this.minDirtyY, this.maxDirtyX + 1 - this.minDirtyX, this.maxDirtyY + 1 - this.minDirtyY);
+            return new SMapDataPacket(FilledMapItem.getMapId(p_176101_1_), MapData.this.scale, MapData.this.trackingPosition, MapData.this.locked, icons, render.buffer, this.minDirtyX, this.minDirtyY, this.maxDirtyX + 1 - this.minDirtyX, this.maxDirtyY + 1 - this.minDirtyY);
          } else {
-            return this.tick++ % 5 == 0 ? new SMapDataPacket(FilledMapItem.getMapId(p_176101_1_), MapData.this.scale, MapData.this.trackingPosition, MapData.this.locked, MapData.this.decorations.values(), MapData.this.colors, 0, 0, 0, 0) : null;
+            return this.tick++ % 5 == 0 ? new SMapDataPacket(FilledMapItem.getMapId(p_176101_1_), MapData.this.scale, MapData.this.trackingPosition, MapData.this.locked, icons, render.buffer, 0, 0, 0, 0) : null;
          }
+         // CraftBukkit end
       }
 
       public void markDirty(int p_176102_1_, int p_176102_2_) {
