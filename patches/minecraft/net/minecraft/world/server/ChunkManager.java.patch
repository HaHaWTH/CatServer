--- a/net/minecraft/world/server/ChunkManager.java
+++ b/net/minecraft/world/server/ChunkManager.java
@@ -1,5 +_,6 @@
 package net.minecraft.world.server;
 
+import catserver.server.utils.CatServerCallbackExecutor;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
@@ -12,6 +_,7 @@
 import it.unimi.dsi.fastutil.longs.Long2ByteMap;
 import it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry;
 import it.unimi.dsi.fastutil.longs.LongIterator;
 import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
 import it.unimi.dsi.fastutil.longs.LongSet;
@@ -55,6 +_,7 @@
 import net.minecraft.network.play.server.SUpdateChunkPositionPacket;
 import net.minecraft.network.play.server.SUpdateLightPacket;
 import net.minecraft.profiler.IProfiler;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.util.CSVWriter;
 import net.minecraft.util.ClassInheritanceMultiMap;
 import net.minecraft.util.Util;
@@ -91,12 +_,14 @@
 import org.apache.commons.lang3.mutable.MutableBoolean;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.bukkit.entity.NPC;
+import org.bukkit.entity.Player;
 
 public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProvider {
    private static final Logger LOGGER = LogManager.getLogger();
    public static final int MAX_CHUNK_DISTANCE = 33 + ChunkStatus.maxDistance();
    private final Long2ObjectLinkedOpenHashMap<ChunkHolder> updatingChunkMap = new Long2ObjectLinkedOpenHashMap<>();
-   private volatile Long2ObjectLinkedOpenHashMap<ChunkHolder> visibleChunkMap = this.updatingChunkMap.clone();
+   public volatile Long2ObjectLinkedOpenHashMap<ChunkHolder> visibleChunkMap = this.updatingChunkMap.clone();
    private final Long2ObjectLinkedOpenHashMap<ChunkHolder> pendingUnloads = new Long2ObjectLinkedOpenHashMap<>();
    private final LongSet entitiesInLevel = new LongOpenHashSet();
    private final ServerWorld level;
@@ -110,15 +_,16 @@
    private final ChunkTaskPriorityQueueSorter queueSorter;
    private final ITaskExecutor<ChunkTaskPriorityQueueSorter.FunctionEntry<Runnable>> worldgenMailbox;
    private final ITaskExecutor<ChunkTaskPriorityQueueSorter.FunctionEntry<Runnable>> mainThreadMailbox;
-   private final IChunkStatusListener progressListener;
-   private final ChunkManager.ProxyTicketManager distanceManager;
+   public final IChunkStatusListener progressListener;
+   public final ChunkManager.ProxyTicketManager distanceManager;
    private final AtomicInteger tickingGenerated = new AtomicInteger();
    private final TemplateManager structureManager;
    private final File storageFolder;
    private final PlayerGenerationTracker playerMap = new PlayerGenerationTracker();
-   private final Int2ObjectMap<ChunkManager.EntityTracker> entityMap = new Int2ObjectOpenHashMap<>();
+   public final Int2ObjectMap<ChunkManager.EntityTracker> entityMap = new Int2ObjectOpenHashMap<>();
    private final Long2ByteMap chunkTypeCache = new Long2ByteOpenHashMap();
    private final Queue<Runnable> unloadQueue = Queues.newConcurrentLinkedQueue();
+   public final CatServerCallbackExecutor callbackExecutor = new CatServerCallbackExecutor(); // CatServer
    private int viewDistance;
 
    public ChunkManager(ServerWorld p_i232602_1_, SaveFormat.LevelSave p_i232602_2_, DataFixer p_i232602_3_, TemplateManager p_i232602_4_, Executor p_i232602_5_, ThreadTaskExecutor<Runnable> p_i232602_6_, IChunkLightProvider p_i232602_7_, ChunkGenerator p_i232602_8_, IChunkStatusListener p_i232602_9_, Supplier<DimensionSavedDataManager> p_i232602_10_, int p_i232602_11_, boolean p_i232602_12_) {
@@ -176,12 +_,12 @@
    }
 
    @Nullable
-   protected ChunkHolder getUpdatingChunkIfPresent(long p_219220_1_) {
+   public ChunkHolder getUpdatingChunkIfPresent(long p_219220_1_) {
       return this.updatingChunkMap.get(p_219220_1_);
    }
 
    @Nullable
-   protected ChunkHolder getVisibleChunkIfPresent(long p_219219_1_) {
+   public ChunkHolder getVisibleChunkIfPresent(long p_219219_1_) {
       return this.visibleChunkMap.get(p_219219_1_);
    }
 
@@ -357,6 +_,8 @@
 
    }
 
+   private static final double UNLOAD_QUEUE_RESIZE_FACTOR = 0.96; // Spigot
+
    protected void tick(BooleanSupplier p_219204_1_) {
       IProfiler iprofiler = this.level.getProfiler();
       iprofiler.push("poi");
@@ -400,6 +_,7 @@
             if (this.pendingUnloads.remove(p_219212_1_, p_219212_3_) && p_219185_5_ != null) {
                if (p_219185_5_ instanceof Chunk) {
                   ((Chunk)p_219185_5_).setLoaded(false);
+                  net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.world.ChunkEvent.Unload((Chunk)p_219185_5_));
                }
 
                this.save(p_219185_5_);
@@ -581,25 +_,31 @@
             chunk.runPostLoad();
             if (this.entitiesInLevel.add(chunkpos.toLong())) {
                chunk.setLoaded(true);
-               this.level.addAllPendingBlockEntities(chunk.getBlockEntities().values());
-               List<Entity> list = null;
-               ClassInheritanceMultiMap<Entity>[] aclassinheritancemultimap = chunk.getEntitySections();
-               int i = aclassinheritancemultimap.length;
+               try{
+                  p_219200_1_.currentlyLoading = chunk; //Forge - bypass the future chain when getChunk is called, this prevents deadlocks.
+                  this.level.addAllPendingBlockEntities(chunk.getBlockEntities().values());
+                  List<Entity> list = null;
+                  ClassInheritanceMultiMap<Entity>[] aclassinheritancemultimap = chunk.getEntitySections();
+                  int i = aclassinheritancemultimap.length;
 
-               for(int j = 0; j < i; ++j) {
-                  for(Entity entity : aclassinheritancemultimap[j]) {
-                     if (!(entity instanceof PlayerEntity) && !this.level.loadFromChunk(entity)) {
-                        if (list == null) {
-                           list = Lists.newArrayList(entity);
-                        } else {
-                           list.add(entity);
+                  for(int j = 0; j < i; ++j) {
+                     for(Entity entity : aclassinheritancemultimap[j]) {
+                        if (!(entity instanceof PlayerEntity) && !this.level.loadFromChunk(entity)) {
+                           if (list == null) {
+                              list = Lists.newArrayList(entity);
+                           } else {
+                              list.add(entity);
+                           }
                         }
                      }
                   }
-               }
 
-               if (list != null) {
-                  list.forEach(chunk::removeEntity);
+                  if (list != null) {
+                     list.forEach(chunk::removeEntity);
+                  }
+                  net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.world.ChunkEvent.Load(chunk));
+            } finally {
+                  p_219200_1_.currentlyLoading = null;//Forge - Stop bypassing the future chain.
                }
             }
 
@@ -678,6 +_,7 @@
 
             this.level.getProfiler().incrementCounter("chunkSave");
             CompoundNBT compoundnbt = ChunkSerializer.write(this.level, p_219229_1_);
+            net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.world.ChunkDataEvent.Save(p_219229_1_, p_219229_1_.getWorldForge() != null ? p_219229_1_.getWorldForge() : this.level, compoundnbt));
             this.write(chunkpos, compoundnbt);
             this.markPosition(chunkpos, chunkstatus.getChunkType());
             return true;
@@ -734,6 +_,7 @@
 
    protected void updateChunkTracking(ServerPlayerEntity p_219199_1_, ChunkPos p_219199_2_, IPacket<?>[] p_219199_3_, boolean p_219199_4_, boolean p_219199_5_) {
       if (p_219199_1_.level == this.level) {
+         net.minecraftforge.event.ForgeEventFactory.fireChunkWatch(p_219199_4_, p_219199_5_, p_219199_1_, p_219199_2_, this.level);
          if (p_219199_5_ && !p_219199_4_) {
             ChunkHolder chunkholder = this.getVisibleChunkIfPresent(p_219199_2_.toLong());
             if (chunkholder != null) {
@@ -806,9 +_,20 @@
    }
 
    boolean noPlayersCloseForSpawning(ChunkPos p_219243_1_) {
-      long i = p_219243_1_.toLong();
+      // Spigot start
+      return isOutsideOfRange(p_219243_1_, false);
+   }
+
+   boolean isOutsideOfRange(ChunkPos chunkPosIn, boolean reducedRange) {
+      int chunkRange = level.spigotConfig.mobSpawnRange;
+      chunkRange = (chunkRange > level.spigotConfig.viewDistance) ? (byte) level.spigotConfig.viewDistance : chunkRange;
+      chunkRange = (chunkRange > 8) ? 8 : chunkRange;
+      double blockRange = (reducedRange) ? Math.pow(chunkRange << 4, 2) : 16384.0D;
+      // Spigot end
+
+      long i = chunkPosIn.toLong();
       return !this.distanceManager.hasPlayersNearby(i) ? true : this.playerMap.getPlayers(i).noneMatch((p_219201_1_) -> {
-         return !p_219201_1_.isSpectator() && euclideanDistanceSquared(p_219243_1_, p_219201_1_) < 16384.0D;
+         return !p_219201_1_.isSpectator() && euclideanDistanceSquared(chunkPosIn, p_219201_1_) < blockRange; // Spigot
       });
    }
 
@@ -942,9 +_,10 @@
    }
 
    protected void addEntity(Entity p_219210_1_) {
-      if (!(p_219210_1_ instanceof EnderDragonPartEntity)) {
+      if (!(p_219210_1_ instanceof net.minecraftforge.entity.PartEntity)) {
          EntityType<?> entitytype = p_219210_1_.getType();
          int i = entitytype.clientTrackingRange() * 16;
+         i = org.spigotmc.TrackingRange.getEntityTrackingRange(p_219210_1_, i); // Spigot
          int j = entitytype.updateInterval();
          if (this.entityMap.containsKey(p_219210_1_.getId())) {
             throw (IllegalStateException)Util.pauseInIde(new IllegalStateException("Entity is already tracked!"));
@@ -1077,15 +_,30 @@
       });
    }
 
-   class EntityTracker {
+   public void removeTracker(ChunkManager tracker, ServerPlayerEntity playerEntity, int entityId) {
+      ChunkManager.EntityTracker entry = tracker.entityMap.get(entityId);
+      if (entry != null) {
+         entry.removePlayer(playerEntity);
+      }
+   }
+
+   public void updateTrackingState(ChunkManager tracker, ServerPlayerEntity playerEntity, int entityId) {
+      ChunkManager.EntityTracker entry = tracker.entityMap.get(entityId);
+      if (entry != null && !entry.seenBy.contains(playerEntity)) {
+         entry.updatePlayer(playerEntity);
+      }
+   }
+
+   public class EntityTracker {
       private final TrackedEntity serverEntity;
       private final Entity entity;
       private final int range;
       private SectionPos lastSectionPos;
-      private final Set<ServerPlayerEntity> seenBy = Sets.newHashSet();
+      public final Set<ServerPlayerEntity> seenBy = Sets.newHashSet();
 
       public EntityTracker(Entity p_i50468_2_, int p_i50468_3_, int p_i50468_4_, boolean p_i50468_5_) {
          this.serverEntity = new TrackedEntity(ChunkManager.this.level, p_i50468_2_, p_i50468_4_, p_i50468_5_, this::broadcast);
+         this.serverEntity.setTrackedPlayers(seenBy);
          this.entity = p_i50468_2_;
          this.range = p_i50468_3_;
          this.lastSectionPos = SectionPos.of(p_i50468_2_);
@@ -1134,7 +_,8 @@
 
       public void updatePlayer(ServerPlayerEntity p_219400_1_) {
          if (p_219400_1_ != this.entity) {
-            Vector3d vector3d = p_219400_1_.position().subtract(this.serverEntity.sentPos());
+            //Vector3d vector3d = p_219400_1_.position().subtract(this.entity.position());  // MC-155077, SPIGOT-5113
+            Vector3d vector3d = p_219400_1_.position().subtract(this.serverEntity.sentPos()); // CatServer - keep vanilla logic, fix mixin inject exception
             int i = Math.min(this.getEffectiveRange(), (ChunkManager.this.viewDistance - 1) * 16);
             boolean flag = vector3d.x >= (double)(-i) && vector3d.x <= (double)i && vector3d.z >= (double)(-i) && vector3d.z <= (double)i && this.entity.broadcastToPlayer(p_219400_1_);
             if (flag) {
@@ -1146,6 +_,16 @@
                      flag1 = ChunkManager.checkerboardDistance(chunkpos, p_219400_1_, false) <= ChunkManager.this.viewDistance;
                   }
                }
+
+               // CraftBukkit start - respect vanish API
+               if (this.entity instanceof ServerPlayerEntity) {
+                  Player craftPlayer = ((ServerPlayerEntity) this.entity).getBukkitEntity();
+                  if (!p_219400_1_.getBukkitEntity().canSee(craftPlayer)) {
+                     flag1 = false;
+                  }
+               }
+               p_219400_1_.entitiesToRemove.remove(Integer.valueOf(this.entity.getId()));
+               // CraftBukkit end
 
                if (flag1 && this.seenBy.add(p_219400_1_)) {
                   this.serverEntity.addPairing(p_219400_1_);
