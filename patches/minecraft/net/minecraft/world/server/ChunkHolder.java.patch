--- a/net/minecraft/world/server/ChunkHolder.java
+++ b/net/minecraft/world/server/ChunkHolder.java
@@ -18,6 +_,7 @@
 import net.minecraft.network.play.server.SMultiBlockChangePacket;
 import net.minecraft.network.play.server.SUpdateLightPacket;
 import net.minecraft.network.play.server.SUpdateTileEntityPacket;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.tileentity.TileEntity;
 import net.minecraft.util.Util;
 import net.minecraft.util.math.BlockPos;
@@ -48,7 +_,7 @@
    private volatile CompletableFuture<Either<Chunk, ChunkHolder.IChunkLoadingError>> tickingChunkFuture = UNLOADED_LEVEL_CHUNK_FUTURE;
    private volatile CompletableFuture<Either<Chunk, ChunkHolder.IChunkLoadingError>> entityTickingChunkFuture = UNLOADED_LEVEL_CHUNK_FUTURE;
    private CompletableFuture<IChunk> chunkToSave = CompletableFuture.completedFuture((IChunk)null);
-   private int oldTicketLevel;
+   public int oldTicketLevel;
    private int ticketLevel;
    private int queueLevel;
    private final ChunkPos pos;
@@ -58,9 +_,10 @@
    private int skyChangedLightSectionFilter;
    private final WorldLightManager lightEngine;
    private final ChunkHolder.IListener onLevelChange;
-   private final ChunkHolder.IPlayerProvider playerProvider;
+   public final ChunkHolder.IPlayerProvider playerProvider;
    private boolean wasAccessibleSinceLastSave;
    private boolean resendLight;
+   Chunk currentlyLoading; //Forge - Used to bypass future chain when loading chunks.
 
    public ChunkHolder(ChunkPos p_i50716_1_, int p_i50716_2_, WorldLightManager p_i50716_3_, ChunkHolder.IListener p_i50716_4_, ChunkHolder.IPlayerProvider p_i50716_5_) {
       this.pos = p_i50716_1_;
@@ -73,6 +_,21 @@
       this.setTicketLevel(p_i50716_2_);
    }
 
+   // CraftBukkit start
+   public Chunk getFullChunk() {
+      if (!getFullChunkStatus(this.oldTicketLevel).isOrAfter(LocationType.BORDER)) {
+         return null; // note: using oldTicketLevel for isLoaded checks
+      }
+      return this.getFullChunkUnchecked();
+   }
+
+   public Chunk getFullChunkUnchecked() {
+      CompletableFuture<Either<IChunk, IChunkLoadingError>> statusFuture = this.getFutureIfPresentUnchecked(ChunkStatus.FULL);
+      Either<IChunk, IChunkLoadingError> either = (Either<IChunk, IChunkLoadingError>) statusFuture.getNow(null);
+      return (either == null) ? null : (Chunk) either.left().orElse(null);
+   }
+   // CraftBukkit end
+
    public CompletableFuture<Either<IChunk, ChunkHolder.IChunkLoadingError>> getFutureIfPresentUnchecked(ChunkStatus p_219301_1_) {
       CompletableFuture<Either<IChunk, ChunkHolder.IChunkLoadingError>> completablefuture = this.futures.get(p_219301_1_.getIndex());
       return completablefuture == null ? UNLOADED_CHUNK_FUTURE : completablefuture;
@@ -139,6 +_,7 @@
       Chunk chunk = this.getTickingChunk();
       if (chunk != null) {
          byte b0 = (byte)SectionPos.blockToSectionCoord(p_244386_1_.getY());
+         if (b0 < 0 || b0 > 15) return;
          if (this.changedBlocksPerSection[b0] == null) {
             this.hasChangedSections = true;
             this.changedBlocksPerSection[b0] = new ShortArraySet();
@@ -204,7 +_,7 @@
    }
 
    private void broadcastBlockEntityIfNeeded(World p_244385_1_, BlockPos p_244385_2_, BlockState p_244385_3_) {
-      if (p_244385_3_.getBlock().isEntityBlock()) {
+      if (p_244385_3_.hasTileEntity()) {
          this.broadcastBlockEntity(p_244385_1_, p_244385_2_);
       }
 
@@ -289,6 +_,30 @@
       boolean flag1 = this.ticketLevel <= ChunkManager.MAX_CHUNK_DISTANCE;
       ChunkHolder.LocationType chunkholder$locationtype = getFullChunkStatus(this.oldTicketLevel);
       ChunkHolder.LocationType chunkholder$locationtype1 = getFullChunkStatus(this.ticketLevel);
+
+      // CraftBukkit start
+      // ChunkUnloadEvent: Called before the chunk is unloaded: isChunkLoaded is still true and chunk can still be modified by plugins.
+      if (chunkholder$locationtype.isOrAfter(LocationType.BORDER) && !chunkholder$locationtype1.isOrAfter(LocationType.BORDER)) {
+         this.getFutureIfPresentUnchecked(ChunkStatus.FULL).thenAccept((either) -> {
+            Chunk chunk = (Chunk) either.left().orElse(null);
+            if (chunk != null) {
+               p_219291_1_.callbackExecutor.execute(() -> {
+                  // Minecraft will apply the chunks tick lists to the world once the chunk got loaded, and then store the tick
+                  // lists again inside the chunk once the chunk becomes inaccessible and set the chunk's needsSaving flag.
+                  // These actions may however happen deferred, so we manually set the needsSaving flag already here.
+                  chunk.setUnsaved(true);
+                  chunk.unloadCallback();
+               });
+            }
+         }).exceptionally((throwable) -> {
+            // ensure exceptions are printed, by default this is not the case
+            MinecraftServer.LOGGER.fatal("Failed to schedule unload callback for chunk " + this.pos, throwable);
+            return null;
+         });
+         // Run callback right away if the future was already done
+         p_219291_1_.callbackExecutor.run();
+      }
+
       if (flag) {
          Either<IChunk, ChunkHolder.IChunkLoadingError> either = Either.right(new ChunkHolder.IChunkLoadingError() {
             public String toString() {
@@ -352,6 +_,23 @@
 
       this.onLevelChange.onLevelChange(this.pos, this::getQueueLevel, this.ticketLevel, this::setQueueLevel);
       this.oldTicketLevel = this.ticketLevel;
+      // CraftBukkit start
+      // ChunkLoadEvent: Called after the chunk is loaded: isChunkLoaded returns true and chunk is ready to be modified by plugins.
+      if (!chunkholder$locationtype.isOrAfter(LocationType.BORDER) && chunkholder$locationtype1.isOrAfter(LocationType.BORDER)) {
+         this.getFutureIfPresentUnchecked(ChunkStatus.FULL).thenAccept((either) -> {
+            Chunk chunk = (Chunk) either.left().orElse(null);
+            if (chunk != null) {
+               p_219291_1_.callbackExecutor.execute(chunk::loadCallback);
+            }
+         }).exceptionally((throwable) -> {
+            // ensure exceptions are printed, by default this is not the case
+            MinecraftServer.LOGGER.fatal("Failed to schedule load callback for chunk " + this.pos, throwable);
+            return null;
+         });
+         // Run callback right away if the future was already done
+         p_219291_1_.callbackExecutor.run();
+      }
+      // CraftBukkit end
    }
 
    public static ChunkStatus getStatus(int p_219278_0_) {
