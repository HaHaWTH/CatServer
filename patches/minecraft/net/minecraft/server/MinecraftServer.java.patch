--- a/net/minecraft/server/MinecraftServer.java
+++ b/net/minecraft/server/MinecraftServer.java
@@ -1,18 +_,5 @@
 package net.minecraft.server;
 
-import com.google.common.base.Splitter;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
-import com.google.common.collect.Sets;
-import com.mojang.authlib.GameProfile;
-import com.mojang.authlib.GameProfileRepository;
-import com.mojang.authlib.minecraft.MinecraftSessionService;
-import com.mojang.datafixers.DataFixer;
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ByteBufOutputStream;
-import io.netty.buffer.Unpooled;
-import it.unimi.dsi.fastutil.longs.LongIterator;
 import java.awt.image.BufferedImage;
 import java.io.File;
 import java.io.IOException;
@@ -37,19 +_,53 @@
 import java.util.Date;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
 import java.util.Objects;
 import java.util.Optional;
 import java.util.Random;
 import java.util.Set;
 import java.util.UUID;
-import java.util.Map.Entry;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.BooleanSupplier;
 import java.util.function.Function;
+
 import javax.annotation.Nullable;
 import javax.imageio.ImageIO;
+
+import com.mojang.serialization.Lifecycle;
+import net.minecraft.world.storage.*;
+import org.apache.commons.lang3.Validate;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.v1_16_R3.CraftServer;
+import org.bukkit.craftbukkit.v1_16_R3.SpigotTimings;
+import org.bukkit.event.server.ServerLoadEvent;
+import org.bukkit.event.world.WorldInitEvent;
+import org.bukkit.event.world.WorldLoadEvent;
+import org.spigotmc.CustomTimingsHandler;
+import org.spigotmc.SlackActivityAccountant;
+
+import com.google.common.base.Splitter;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+
+import moe.loliserver.BukkitInjector;
+import com.mojang.authlib.GameProfile;
+import com.mojang.authlib.GameProfileRepository;
+import com.mojang.authlib.minecraft.MinecraftSessionService;
+import com.mojang.datafixers.DataFixer;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufOutputStream;
+import io.netty.buffer.Unpooled;
+import io.papermc.paper.event.server.ServerResourcesReloadedEvent;
+import it.unimi.dsi.fastutil.longs.LongIterator;
+import joptsimple.OptionSet;
 import net.minecraft.advancements.AdvancementManager;
 import net.minecraft.advancements.FunctionManager;
 import net.minecraft.block.Block;
@@ -81,6 +_,7 @@
 import net.minecraft.resources.ResourcePackList;
 import net.minecraft.scoreboard.ScoreboardSaveData;
 import net.minecraft.scoreboard.ServerScoreboard;
+import net.minecraft.server.dedicated.DedicatedServer;
 import net.minecraft.server.management.OpEntry;
 import net.minecraft.server.management.PlayerList;
 import net.minecraft.server.management.PlayerProfileCache;
@@ -140,41 +_,29 @@
 import net.minecraft.world.spawner.PatrolSpawner;
 import net.minecraft.world.spawner.PhantomSpawner;
 import net.minecraft.world.spawner.WanderingTraderSpawner;
-import net.minecraft.world.storage.CommandStorage;
-import net.minecraft.world.storage.DerivedWorldInfo;
-import net.minecraft.world.storage.DimensionSavedDataManager;
-import net.minecraft.world.storage.FolderName;
-import net.minecraft.world.storage.IServerConfiguration;
-import net.minecraft.world.storage.IServerWorldInfo;
-import net.minecraft.world.storage.IWorldInfo;
-import net.minecraft.world.storage.PlayerData;
-import net.minecraft.world.storage.SaveFormat;
-import net.minecraft.world.storage.WorldSavedDataCallableSave;
 import net.minecraftforge.api.distmarker.Dist;
 import net.minecraftforge.api.distmarker.OnlyIn;
-import org.apache.commons.lang3.Validate;
-import org.apache.logging.log4j.LogManager;
-import org.apache.logging.log4j.Logger;
+import net.minecraftforge.common.MinecraftForge;
 
 public abstract class MinecraftServer extends RecursiveEventLoop<TickDelayedTask> implements ISnooperInfo, ICommandSource, AutoCloseable {
-   private static final Logger LOGGER = LogManager.getLogger();
+   public static final Logger LOGGER = LogManager.getLogger();
    public static final File USERID_CACHE_FILE = new File("usercache.json");
    public static final WorldSettings DEMO_SETTINGS = new WorldSettings("Demo World", GameType.SURVIVAL, false, Difficulty.NORMAL, false, new GameRules(), DatapackCodec.DEFAULT);
-   protected final SaveFormat.LevelSave storageSource;
-   protected final PlayerData playerDataStorage;
+   public final SaveFormat.LevelSave storageSource;
+   public final PlayerData playerDataStorage;
    private final Snooper snooper = new Snooper("server", this, Util.getMillis());
    private final List<Runnable> tickables = Lists.newArrayList();
    private final TimeTracker continousProfiler = new TimeTracker(Util.timeSource, this::getTickCount);
    private IProfiler profiler = EmptyProfiler.INSTANCE;
-   private final NetworkSystem connection;
-   private final IChunkStatusListenerFactory progressListenerFactory;
+   private NetworkSystem connection;
+   public final IChunkStatusListenerFactory progressListenerFactory;
    private final ServerStatusResponse status = new ServerStatusResponse();
    private final Random random = new Random();
-   private final DataFixer fixerUpper;
+   public final DataFixer fixerUpper;
    private String localIp;
    private int port = -1;
-   protected final DynamicRegistries.Impl registryHolder;
-   private final Map<RegistryKey<World>, ServerWorld> levels = Maps.newLinkedHashMap();
+   public final DynamicRegistries.Impl registryHolder;
+   public final Map<RegistryKey<World>, ServerWorld> levels = Maps.newLinkedHashMap();
    private PlayerList playerList;
    private volatile boolean running = true;
    private boolean stopped;
@@ -204,7 +_,7 @@
    private final GameProfileRepository profileRepository;
    private final PlayerProfileCache profileCache;
    private long lastServerStatus;
-   private final Thread serverThread;
+   public final Thread serverThread;
    protected long nextTickTime = Util.getMillis();
    private long delayedTasksMaxNextTickTime;
    private boolean mayHaveDelayedTasks;
@@ -219,16 +_,39 @@
    private final FrameTimer frameTimer = new FrameTimer();
    private boolean enforceWhitelist;
    private float averageTickTime;
-   private final Executor executor;
+   public final Executor executor;
    @Nullable
    private String serverId;
-   private DataPackRegistries resources;
+   public DataPackRegistries resources;
    private final TemplateManager structureManager;
-   protected final IServerConfiguration worldData;
+   protected IServerConfiguration worldData;
+
+   @Nullable
+   public static DatapackCodec defaultDatapackCodec; // CatServer
+
+   // CraftBukkit start
+   public DatapackCodec datapackconfiguration;
+   public CraftServer server;
+   public static OptionSet options;
+   public org.bukkit.command.ConsoleCommandSender console;
+   public org.bukkit.command.RemoteConsoleCommandSender remoteConsole;
+   public static int currentTick = (int) (System.currentTimeMillis() / 50);
+   public java.util.Queue<Runnable> processQueue = new java.util.concurrent.ConcurrentLinkedQueue<Runnable>();
+   public int autosavePeriod;
+   public Commands vanillaCommandDispatcher;
+   private boolean forceTicks;
+   // CraftBukkit end
+   // Spigot start
+   public static final int TPS = 20;
+   public static final int TICK_TIME = 1000000000 / TPS;
+   private static final int SAMPLE_INTERVAL = 100;
+   public final double[] recentTps = new double[ 3 ];
+   public final SlackActivityAccountant slackActivityAccountant = new SlackActivityAccountant();
+   // Spigot end
 
    public static <S extends MinecraftServer> S spin(Function<Thread, S> p_240784_0_) {
       AtomicReference<S> atomicreference = new AtomicReference<>();
-      Thread thread = new Thread(() -> {
+      Thread thread = new Thread(net.minecraftforge.fml.common.thread.SidedThreadGroups.SERVER, () -> {
          atomicreference.get().runServer();
       }, "Server thread");
       thread.setUncaughtExceptionHandler((p_240779_0_, p_240779_1_) -> {
@@ -259,7 +_,11 @@
       this.structureManager = new TemplateManager(p_i232576_8_.getResourceManager(), p_i232576_3_, p_i232576_7_);
       this.serverThread = p_i232576_1_;
       this.executor = Util.backgroundExecutor();
+      this.datapackconfiguration = defaultDatapackCodec;
+      // CraftBukkit start
+      this.vanillaCommandDispatcher = p_i232576_8_.commands; // CraftBukkit
    }
+   // CraftBukkit end
 
    private void readScoreboard(DimensionSavedDataManager p_213204_1_) {
       ScoreboardSaveData scoreboardsavedata = p_213204_1_.computeIfAbsent(ScoreboardSaveData::new, "scoreboard");
@@ -332,6 +_,7 @@
          chunkgenerator = dimension.generator();
       }
 
+      BukkitInjector.addEnumEnvironment();
       ServerWorld serverworld = new ServerWorld(this, this.executor, this.storageSource, iserverworldinfo, World.OVERWORLD, dimensiontype, p_240787_1_, chunkgenerator, flag, j, list, true);
       this.levels.put(World.OVERWORLD, serverworld);
       DimensionSavedDataManager dimensionsaveddatamanager = serverworld.getDataStorage();
@@ -371,13 +_,36 @@
             RegistryKey<World> registrykey1 = RegistryKey.create(Registry.DIMENSION_REGISTRY, registrykey.location());
             DimensionType dimensiontype1 = entry.getValue().type();
             ChunkGenerator chunkgenerator1 = entry.getValue().generator();
-            DerivedWorldInfo derivedworldinfo = new DerivedWorldInfo(this.worldData, iserverworldinfo);
+            DerivedWorldInfo derivedworldinfo = new DerivedWorldInfo(this.worldData, iserverworldinfo, DimensionType.getStorageFolder(registrykey1, this.storageSource.getWorldDir().toFile()).getName());
             ServerWorld serverworld1 = new ServerWorld(this, this.executor, this.storageSource, derivedworldinfo, registrykey1, dimensiontype1, p_240787_1_, chunkgenerator1, flag, j, ImmutableList.of(), false);
+            serverworld1.worldDataServer = new ServerWorldInfo(new WorldSettings(derivedworldinfo.getLevelName(), derivedworldinfo.getGameType(), derivedworldinfo.isHardcore(), derivedworldinfo.getDifficulty(), false, derivedworldinfo.getGameRules(), this.datapackconfiguration), ((ServerWorldInfo)iserverworldinfo).worldGenSettings(), Lifecycle.stable()); //Fixme
             worldborder.addListener(new IBorderListener.Impl(serverworld1.getWorldBorder()));
             this.levels.put(registrykey1, serverworld1);
+            if (this.server.scoreboardManager == null) {
+               this.server.scoreboardManager = new org.bukkit.craftbukkit.v1_16_R3.scoreboard.CraftScoreboardManager(this, serverworld1.getScoreboard());
+            }
+            if (serverworld1.generator != null) {
+               serverworld1.getWorld().getPopulators().addAll(serverworld1.generator.getDefaultPopulators(serverworld1.getWorld()));
+            }
+            // CatServer start - Fix Multiverse-Core plugin
+            if (!"minecraft".equals(registrykey.location().getNamespace()) ) {
+               try {
+                  File bukkitWorldDir = new File(overworld().convertable.getWorldDir().toFile(), registrykey.location().getPath());
+                  if (!bukkitWorldDir.exists()) {
+                     bukkitWorldDir.mkdir(); // Create empty dir to bypass Multiverse-Core check
+                  }
+               } catch (Exception e) {
+                  System.out.println(e.toString());
+               }
+            }
+            // CatServer end
          }
+         Bukkit.getPluginManager().callEvent(new WorldInitEvent(levels.get(registrykey).getWorld()));
+         net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.world.WorldEvent.Load(levels.get(registrykey)));
       }
-
+      this.server.enablePlugins(org.bukkit.plugin.PluginLoadOrder.POSTWORLD);
+      this.server.getPluginManager().callEvent(new ServerLoadEvent(ServerLoadEvent.LoadType.STARTUP));
+      this.connection.acceptConnections();
    }
 
    private static void setInitialSpawn(ServerWorld p_240786_0_, IServerWorldInfo p_240786_1_, boolean p_240786_2_, boolean p_240786_3_, boolean p_240786_4_) {
@@ -387,6 +_,7 @@
       } else if (p_240786_3_) {
          p_240786_1_.setSpawn(BlockPos.ZERO.above(), 0.0F);
       } else {
+         if (net.minecraftforge.event.ForgeEventFactory.onCreateWorldSpawn(p_240786_0_, p_240786_1_)) return;
          BiomeProvider biomeprovider = chunkgenerator.getBiomeSource();
          Random random = new Random(p_240786_0_.getSeed());
          BlockPos blockpos = biomeprovider.findBiomeHorizontal(0, p_240786_0_.getSeaLevel(), 0, 256, (p_244265_0_) -> {
@@ -452,7 +_,10 @@
    }
 
    private void prepareLevels(IChunkStatusListener p_213186_1_) {
+      net.minecraftforge.common.world.StructureSpawnManager.gatherEntitySpawns();
       ServerWorld serverworld = this.overworld();
+      this.forceTicks = true;
+      // CraftBukkit end
       LOGGER.info("Preparing start region for dimension {}", (Object)serverworld.dimension().location());
       BlockPos blockpos = serverworld.getSharedSpawnPos();
       p_213186_1_.updateSpawnPos(new ChunkPos(blockpos));
@@ -461,32 +_,40 @@
       this.nextTickTime = Util.getMillis();
       serverchunkprovider.addRegionTicket(TicketType.START, new ChunkPos(blockpos), 11, Unit.INSTANCE);
 
-      while(serverchunkprovider.getTickingGenerated() != 441) {
-         this.nextTickTime = Util.getMillis() + 10L;
-         this.waitUntilNextTick();
+      while(serverchunkprovider.getTickingGenerated() < 441) {
+         // CraftBukkit start
+         this.executeModerately();
+         // CraftBukkit end
       }
 
-      this.nextTickTime = Util.getMillis() + 10L;
-      this.waitUntilNextTick();
-
-      for(ServerWorld serverworld1 : this.levels.values()) {
-         ForcedChunksSaveData forcedchunkssavedata = serverworld1.getDataStorage().get(ForcedChunksSaveData::new, "chunks");
-         if (forcedchunkssavedata != null) {
-            LongIterator longiterator = forcedchunkssavedata.getChunks().iterator();
-
-            while(longiterator.hasNext()) {
-               long i = longiterator.nextLong();
-               ChunkPos chunkpos = new ChunkPos(i);
-               serverworld1.getChunkSource().updateChunkForced(chunkpos, true);
+      // CraftBukkit start
+      //this.nextTick = SystemUtils.getMonotonicMillis() + 10L;
+      this.executeModerately();
+      for (ServerWorld serverworld1 : this.levels.values()) {
+         if (serverworld1.getWorld().getKeepSpawnInMemory()) {
+            ForcedChunksSaveData forcedchunkssavedata = serverworld1.getDataStorage().get(ForcedChunksSaveData::new, "chunks");
+
+            if (forcedchunkssavedata != null) {
+               LongIterator longiterator = forcedchunkssavedata.getChunks().iterator();
+
+               while (longiterator.hasNext()) {
+                  long i = longiterator.nextLong();
+                  ChunkPos chunkpos = new ChunkPos(i);
+                  serverworld1.getChunkSource().updateChunkForced(chunkpos, true);
+               }
             }
          }
+         Bukkit.getPluginManager().callEvent(new WorldLoadEvent(serverworld1.getWorld()));
       }
 
-      this.nextTickTime = Util.getMillis() + 10L;
-      this.waitUntilNextTick();
+      // CraftBukkit start
+      //this.serverTime = Util.milliTime() + 10L;
+      this.executeModerately();
+      // CraftBukkit end
       p_213186_1_.stop();
       serverchunkprovider.getLightEngine().setTaskPerBatch(5);
       this.updateMobSpawningFlags();
+      this.forceTicks = false;
    }
 
    protected void detectBundledResources() {
@@ -534,23 +_,53 @@
       iserverworldinfo.setWorldBorder(serverworld1.getWorldBorder().createSettings());
       this.worldData.setCustomBossEvents(this.getCustomBossEvents().save());
       this.storageSource.saveDataTag(this.registryHolder, this.worldData, this.getPlayerList().getSingleplayerData());
-      return flag;
+      //LoliServer start - save level.dat to all plugin world
+      for (ServerWorld world : this.levels.values()) {
+         if (world.convertable != this.storageSource) {
+            world.worldDataServer.setWorldBorder(world.getWorldBorder().createSettings());
+            world.worldDataServer.setCustomBossEvents(this.getCustomBossEvents().save());
+            world.convertable.saveDataTag(this.registryHolder, world.worldDataServer);
+         }
+      }
+      //LoliServer end
+       return flag;
    }
 
    public void close() {
       this.stopServer();
    }
 
+   // CraftBukkit start
+   private boolean hasStopped = false;
+   private final Object stopLock = new Object();
+   public final boolean hasStopped() {
+      synchronized (stopLock) {
+         return hasStopped;
+      }
+   }
+   // CraftBukkit end
+
    protected void stopServer() {
+      // CraftBukkit start - prevent double stopping on multiple threads
+      synchronized(stopLock) {
+         if (hasStopped) return;
+         hasStopped = true;
+      }
+      // CraftBukkit end
       LOGGER.info("Stopping server");
       if (this.getConnection() != null) {
          this.getConnection().stop();
       }
 
+      if (this.server != null) {
+         this.server.disablePlugins();
+      }
+
       if (this.playerList != null) {
          LOGGER.info("Saving players");
          this.playerList.saveAll();
          this.playerList.removeAll();
+         try { Thread.sleep(100); } catch (InterruptedException ex) {} // CraftBukkit - SPIGOT-625 - give server at least a chance to send packets
       }
 
       LOGGER.info("Saving worlds");
@@ -563,13 +_,17 @@
 
       this.saveAllChunks(false, true, false);
 
-      for(ServerWorld serverworld1 : this.getAllLevels()) {
-         if (serverworld1 != null) {
-            try {
-               serverworld1.close();
-            } catch (IOException ioexception1) {
-               LOGGER.error("Exception closing the level", (Throwable)ioexception1);
+      for(ServerWorld serverworld1 : this.levels.values()) {
+         ForcedChunksSaveData forcedchunkssavedata = serverworld1.getDataStorage().get(ForcedChunksSaveData::new, "chunks");
+         if (forcedchunkssavedata != null) {
+            LongIterator longiterator = forcedchunkssavedata.getChunks().iterator();
+
+            while(longiterator.hasNext()) {
+               long i = longiterator.nextLong();
+               ChunkPos chunkpos = new ChunkPos(i);
+               serverworld1.getChunkSource().updateChunkForced(chunkpos, true);
             }
+            net.minecraftforge.common.world.ForgeChunkManager.reinstatePersistentChunks(serverworld1, forcedchunkssavedata);
          }
       }
 
@@ -584,6 +_,12 @@
       } catch (IOException ioexception) {
          LOGGER.error("Failed to unlock level {}", this.storageSource.getLevelId(), ioexception);
       }
+      // Spigot start
+      if (org.spigotmc.SpigotConfig.saveUserCacheOnStopOnly) {
+         LOGGER.info("Saving usercache.json");
+         this.profileCache.save();
+      }
+      // Spigot end
 
    }
 
@@ -611,23 +_,49 @@
 
    }
 
+   // Spigot Start
+   private static double calcTps(double avg, double exp, double tps)
+   {
+      return ( avg * exp ) + ( tps * ( 1 - exp ) );
+   }
+   // Spigot End
+
    protected void runServer() {
+
       try {
          if (this.initServer()) {
+            net.minecraftforge.fml.server.ServerLifecycleHooks.handleServerStarted(this);
             this.nextTickTime = Util.getMillis();
             this.status.setDescription(new StringTextComponent(this.motd));
             this.status.setVersion(new ServerStatusResponse.Version(SharedConstants.getCurrentVersion().getName(), SharedConstants.getCurrentVersion().getProtocolVersion()));
             this.updateStatusIcon(this.status);
 
+            // Spigot start
+            Arrays.fill( recentTps, 20 );
+            long curTime, tickSection = Util.getMillis(), tickCount = 1;
             while(this.running) {
-               long i = Util.getMillis() - this.nextTickTime;
-               if (i > 2000L && this.nextTickTime - this.lastOverloadWarning >= 15000L) {
+               long i = (curTime = Util.getMillis()) - this.nextTickTime;
+
+               if (i > 5000L && this.nextTickTime - this.lastOverloadWarning >= 30000L) {  // CraftBukkit
                   long j = i / 50L;
-                  LOGGER.warn("Can't keep up! Is the server overloaded? Running {}ms or {} ticks behind", i, j);
+                  if (server.getWarnOnOverload()) {
+                     // LOGGER.warn("Can't keep up! Is the server overloaded? Running {}ms or {} ticks behind", String.valueOf(i), String.valueOf(j)); // LoliServer: Delete Overload Message
+                  }
                   this.nextTickTime += j * 50L;
                   this.lastOverloadWarning = this.nextTickTime;
                }
 
+               if ( tickCount++ % SAMPLE_INTERVAL == 0 )
+               {
+                  double currentTps = 1E3 / ( curTime - tickSection ) * SAMPLE_INTERVAL;
+                  recentTps[0] = calcTps( recentTps[0], 0.92, currentTps ); // 1/exp(5sec/1min)
+                  recentTps[1] = calcTps( recentTps[1], 0.9835, currentTps ); // 1/exp(5sec/5min)
+                  recentTps[2] = calcTps( recentTps[2], 0.9945, currentTps ); // 1/exp(5sec/15min)
+                  tickSection = curTime;
+               }
+               // Spigot end
+
+               currentTick = (int) (System.currentTimeMillis() / 50); // CraftBukkit
                this.nextTickTime += 50L;
                LongTickDetector longtickdetector = LongTickDetector.createTickProfiler("Server");
                this.startProfilerTick(longtickdetector);
@@ -643,11 +_,20 @@
                this.endProfilerTick(longtickdetector);
                this.isReady = true;
             }
+            net.minecraftforge.fml.server.ServerLifecycleHooks.handleServerStopping(this);
+            net.minecraftforge.fml.server.ServerLifecycleHooks.expectServerStopped(); // has to come before finalTick to avoid race conditions
          } else {
+            net.minecraftforge.fml.server.ServerLifecycleHooks.expectServerStopped(); // has to come before finalTick to avoid race conditions
             this.onServerCrash((CrashReport)null);
          }
       } catch (Throwable throwable1) {
          LOGGER.error("Encountered an unexpected exception", throwable1);
+         // Spigot Start
+         if ( throwable1.getCause() != null )
+         {
+            LOGGER.error("\\tCause of unexpected exception was", throwable1.getCause());
+         }
+         // Spigot End
          CrashReport crashreport;
          if (throwable1 instanceof ReportedException) {
             crashreport = this.fillReport(((ReportedException)throwable1).getReport());
@@ -662,6 +_,7 @@
             LOGGER.error("We were unable to save this crash report to disk.");
          }
 
+         net.minecraftforge.fml.server.ServerLifecycleHooks.expectServerStopped(); // has to come before finalTick to avoid race conditions
          this.onServerCrash(crashreport);
       } finally {
          try {
@@ -670,7 +_,12 @@
          } catch (Throwable throwable) {
             LOGGER.error("Exception stopping the server", throwable);
          } finally {
+            net.minecraftforge.fml.server.ServerLifecycleHooks.handleServerStopped(this);
+            org.spigotmc.WatchdogThread.doStop(); // Spigot
+
             this.onServerExit();
+            LogManager.shutdown();
+            Runtime.getRuntime().halt(0);
          }
 
       }
@@ -678,8 +_,16 @@
    }
 
    private boolean haveTime() {
-      return this.runningTask() || Util.getMillis() < (this.mayHaveDelayedTasks ? this.delayedTasksMaxNextTickTime : this.nextTickTime);
-   }
+      // CraftBukkit start
+      return this.forceTicks || this.runningTask() || Util.getMillis() < (this.mayHaveDelayedTasks ? this.delayedTasksMaxNextTickTime : this.nextTickTime);
+   }
+
+   private void executeModerately() {
+      this.runAllTasks();
+      this.drainQueuedTasks();
+      java.util.concurrent.locks.LockSupport.parkNanos("executing tasks", 1000L);
+   }
+   // CraftBukkit end
 
    protected void waitUntilNextTick() {
       this.runAllTasks();
@@ -688,7 +_,7 @@
       });
    }
 
-   protected TickDelayedTask wrapRunnable(Runnable p_212875_1_) {
+   public TickDelayedTask wrapRunnable(Runnable p_212875_1_) {
       return new TickDelayedTask(this.tickCount, p_212875_1_);
    }
 
@@ -767,10 +_,16 @@
    }
 
    protected void onServerExit() {
+      System.exit(0);
    }
 
    protected void tickServer(BooleanSupplier p_71217_1_) {
+      SpigotTimings.serverTickTimer.startTiming(); // Spigot
+      this.slackActivityAccountant.tickStarted(); // Spigot
       long i = Util.getNanos();
+      SpigotTimings.forgePreServerTick.startTiming();
+      net.minecraftforge.fml.hooks.BasicEventHooks.onPreServerTick();
+      SpigotTimings.forgePreServerTick.stopTiming();
       ++this.tickCount;
       this.tickChildren(p_71217_1_);
       if (i - this.lastServerStatus >= 5000000000L) {
@@ -785,23 +_,26 @@
 
          Collections.shuffle(Arrays.asList(agameprofile));
          this.status.getPlayers().setSample(agameprofile);
+         this.status.invalidateJson();
       }
 
-      if (this.tickCount % 6000 == 0) {
+      if (autosavePeriod > 0 && this.tickCount % autosavePeriod == 0) { // CraftBukkit
+         SpigotTimings.worldSaveTimer.startTiming(); // Spigot
          LOGGER.debug("Autosave started");
          this.profiler.push("save");
          this.playerList.saveAll();
          this.saveAllChunks(true, false, false);
          this.profiler.pop();
          LOGGER.debug("Autosave finished");
+         SpigotTimings.worldSaveTimer.stopTiming(); // Spigot
       }
 
       this.profiler.push("snooper");
-      if (!this.snooper.isStarted() && this.tickCount > 100) {
+      if (((DedicatedServer) this).getProperties().snooperEnabled && !this.snooper.isStarted() && this.tickCount > 100) { // Spigot
          this.snooper.start();
       }
 
-      if (this.tickCount % 6000 == 0) {
+      if (((DedicatedServer) this).getProperties().snooperEnabled && this.tickCount % 6000 == 0) {
          this.snooper.prepare();
       }
 
@@ -812,52 +_,119 @@
       long i1 = Util.getNanos();
       this.frameTimer.logFrameDuration(i1 - i);
       this.profiler.pop();
+      org.spigotmc.WatchdogThread.tick(); // Spigot
+      this.slackActivityAccountant.tickEnded(l); // Spigot
+      SpigotTimings.serverTickTimer.stopTiming(); // Spigot
+      SpigotTimings.forgePostServerTick.startTiming();
+      net.minecraftforge.fml.hooks.BasicEventHooks.onPostServerTick();
+      SpigotTimings.forgePostServerTick.stopTiming();
+      CustomTimingsHandler.tick();
    }
 
    protected void tickChildren(BooleanSupplier p_71190_1_) {
+      SpigotTimings.schedulerTimer.startTiming(); // Spigot
+      this.server.getScheduler().mainThreadHeartbeat(this.tickCount); // CraftBukkit
+      SpigotTimings.schedulerTimer.stopTiming(); // Spigot
       this.profiler.push("commandFunctions");
+      SpigotTimings.commandFunctionsTimer.startTiming(); // Spigot
       this.getFunctions().tick();
+      SpigotTimings.commandFunctionsTimer.stopTiming(); // Spigot
       this.profiler.popPush("levels");
 
-      for(ServerWorld serverworld : this.getAllLevels()) {
+      // CraftBukkit start
+      // Run tasks that are waiting on processing
+      SpigotTimings.processQueueTimer.startTiming(); // Spigot
+      this.drainQueuedTasks(); // CatServer
+      SpigotTimings.processQueueTimer.stopTiming(); // Spigot
+
+      catserver.server.command.internal.CommandChunkStats.onServerTick();
+
+      for(ServerWorld serverworld : this.getWorldArray()) {
+         long tickStart = Util.getNanos();
          this.profiler.push(() -> {
             return serverworld + " " + serverworld.dimension().location();
          });
+		 SpigotTimings.timeUpdateTimer.startTiming(); // Spigot
+
+         /*
          if (this.tickCount % 20 == 0) {
             this.profiler.push("timeSync");
             this.playerList.broadcastAll(new SUpdateTimePacket(serverworld.getGameTime(), serverworld.getDayTime(), serverworld.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT)), serverworld.dimension());
             this.profiler.pop();
          }
+         */
+
+         // CraftServer start
+         boolean doDaylight = serverworld.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT);
+         long dayTime = serverworld.getDayTime();
+         long worldTime = serverworld.getGameTime();
+         SUpdateTimePacket worldPacket = new SUpdateTimePacket(worldTime, dayTime, doDaylight);
+         for (ServerPlayerEntity player : serverworld.players()) {
+            if ((this.tickCount + player.getId()) % 20 != 0)
+               continue;
+            long playerTime = player.getPlayerTime();
+            SUpdateTimePacket packet = (playerTime == dayTime) ? worldPacket : new SUpdateTimePacket(worldTime, playerTime, doDaylight);
+            player.connection.send(packet);
+         }
+         // CraftServer end
+         SpigotTimings.timeUpdateTimer.stopTiming(); // Spigot
 
          this.profiler.push("tick");
-
+         serverworld.timings.forgePreWorldTick.startTiming();
+         net.minecraftforge.fml.hooks.BasicEventHooks.onPreWorldTick(serverworld);
+         serverworld.timings.forgePreWorldTick.stopTiming();
          try {
+            serverworld.timings.doTick.startTiming(); // Spigot
             serverworld.tick(p_71190_1_);
+            serverworld.timings.doTick.stopTiming(); // Spigot
          } catch (Throwable throwable) {
-            CrashReport crashreport = CrashReport.forThrowable(throwable, "Exception ticking world");
+            // Spigot Start
+            CrashReport crashreport;
+            try {
+               crashreport = CrashReport.forThrowable(throwable, "Exception ticking world");
+            } catch (Throwable t) {
+               throw new RuntimeException("Error generating crash report", t);
+            }
+            // Spigot End
             serverworld.fillReportDetails(crashreport);
             throw new ReportedException(crashreport);
          }
-
-         this.profiler.pop();
-         this.profiler.pop();
+         serverworld.timings.forgePostWorldTick.startTiming();
+         net.minecraftforge.fml.hooks.BasicEventHooks.onPostWorldTick(serverworld);
+         serverworld.timings.forgePostWorldTick.stopTiming();
+         this.profiler.pop();
+         this.profiler.pop();
+         perWorldTickTimes.computeIfAbsent(serverworld.dimension(), k -> new long[100])[this.tickCount % 100] = Util.getNanos() - tickStart;
+         serverworld.explosionDensityCache.clear(); // Paper - Optimize explosions
       }
 
       this.profiler.popPush("connection");
+      SpigotTimings.connectionTimer.startTiming(); // Spigot
       this.getConnection().tick();
+      SpigotTimings.connectionTimer.stopTiming(); // Spigot
       this.profiler.popPush("players");
+      SpigotTimings.playerListTimer.startTiming(); // Spigot
       this.playerList.tick();
+      SpigotTimings.playerListTimer.stopTiming(); // Spigot
       if (SharedConstants.IS_RUNNING_IN_IDE) {
          TestCollection.singleton.tick();
       }
 
       this.profiler.popPush("server gui refresh");
 
+      SpigotTimings.tickablesTimer.startTiming(); // Spigot
       for(int i = 0; i < this.tickables.size(); ++i) {
          this.tickables.get(i).run();
       }
+      SpigotTimings.tickablesTimer.stopTiming(); // Spigot
 
       this.profiler.pop();
+   }
+
+   public void drainQueuedTasks() {
+      while (!processQueue.isEmpty()) {
+         processQueue.remove().run();
+      }
    }
 
    public boolean isNetherEnabled() {
@@ -915,7 +_,7 @@
    }
 
    public String getServerModName() {
-      return "vanilla";
+      return net.minecraftforge.fml.BrandingControl.getServerBranding();
    }
 
    public CrashReport fillReport(CrashReport p_71230_1_) {
@@ -928,6 +_,7 @@
       p_71230_1_.getSystemDetails().setDetail("Data Packs", () -> {
          StringBuilder stringbuilder = new StringBuilder();
 
+               LogManager.shutdown(); // we're manually managing the logging shutdown on the server. Make sure we do it here at the end.
          for(ResourcePackInfo resourcepackinfo : this.packRepository.getSelectedPacks()) {
             if (stringbuilder.length() > 0) {
                stringbuilder.append(", ");
@@ -953,7 +_,7 @@
    public abstract Optional<String> getModdedStatus();
 
    public void sendMessage(ITextComponent p_145747_1_, UUID p_145747_2_) {
-      LOGGER.info(p_145747_1_.getString());
+      LOGGER.info(org.bukkit.craftbukkit.v1_16_R3.util.CraftChatMessage.fromComponent(p_145747_1_));
    }
 
    public KeyPair getKeyPair() {
@@ -1266,6 +_,10 @@
    }
 
    public CompletableFuture<Void> reloadResources(Collection<String> p_240780_1_) {
+      return this.reloadServerResources(p_240780_1_, ServerResourcesReloadedEvent.Cause.PLUGIN);
+   }
+   // Paper - add cause
+   public CompletableFuture<Void> reloadServerResources(Collection<String> p_240780_1_, ServerResourcesReloadedEvent.Cause cause) {
       CompletableFuture<Void> completablefuture = CompletableFuture.supplyAsync(() -> {
          return p_240780_1_.stream().map(this.packRepository::getPack).filter(Objects::nonNull).map(ResourcePackInfo::open).collect(ImmutableList.toImmutableList());
       }, this).thenCompose((p_240775_1_) -> {
@@ -1273,13 +_,22 @@
       }).thenAcceptAsync((p_240782_2_) -> {
          this.resources.close();
          this.resources = p_240782_2_;
+         this.server.syncCommands(); // SPIGOT-5884: Lost on reload
          this.packRepository.setSelected(p_240780_1_);
          this.worldData.setDataPackConfig(getSelectedPacks(this.packRepository));
          p_240782_2_.updateGlobals();
-         this.getPlayerList().saveAll();
+         // Paper start
+         ServerResourcesReloadedEvent event = new ServerResourcesReloadedEvent(cause);
+         Bukkit.getServer().getPluginManager().callEvent(event);
+         if (Thread.currentThread() != this.serverThread) {
+            return;
+         }
+         //this.getPlayerList().saveAll(); // Paper - we don't need to do this
+         // Paper end
          this.getPlayerList().reloadResources();
          this.functionManager.replaceLibrary(this.resources.getFunctionLibrary());
          this.structureManager.onResourceManagerReload(this.resources.getResourceManager());
+         this.getPlayerList().getPlayers().forEach(this.getPlayerList()::sendPlayerPermissionLevel); //Forge: Fix newly added/modified commands not being sent to the client when commands reload.
       }, this);
       if (this.isSameThread()) {
          this.managedBlock(completablefuture::isDone);
@@ -1289,10 +_,13 @@
    }
 
    public static DatapackCodec configurePackRepository(ResourcePackList p_240772_0_, DatapackCodec p_240772_1_, boolean p_240772_2_) {
+      net.minecraftforge.fml.packs.ResourcePackLoader.loadResourcePacks(p_240772_0_, net.minecraftforge.fml.server.ServerLifecycleHooks::buildPackFinder);
       p_240772_0_.reload();
+      DatapackCodec.DEFAULT.addModPacks(net.minecraftforge.common.ForgeHooks.getModPacks());
+      p_240772_1_.addModPacks(net.minecraftforge.common.ForgeHooks.getModPacks());
       if (p_240772_2_) {
-         p_240772_0_.setSelected(Collections.singleton("vanilla"));
-         return new DatapackCodec(ImmutableList.of("vanilla"), ImmutableList.of());
+         p_240772_0_.setSelected(net.minecraftforge.common.ForgeHooks.getModPacksWithVanilla());
+         return new DatapackCodec(net.minecraftforge.common.ForgeHooks.getModPacksWithVanilla(), ImmutableList.of());
       } else {
          Set<String> set = Sets.newLinkedHashSet();
 
@@ -1335,7 +_,7 @@
       if (this.isEnforceWhitelist()) {
          PlayerList playerlist = p_205743_1_.getServer().getPlayerList();
          WhiteList whitelist = playerlist.getWhiteList();
-
+         if (!((DedicatedServer)getServer()).getProperties().whiteList.get()) return; // Paper - white list not enabled
          for(ServerPlayerEntity serverplayerentity : Lists.newArrayList(playerlist.getPlayers())) {
             if (!whitelist.isWhiteListed(serverplayerentity.getGameProfile())) {
                serverplayerentity.connection.disconnect(new TranslationTextComponent("multiplayer.disconnect.not_whitelisted"));
@@ -1442,6 +_,31 @@
 
    public abstract boolean isSingleplayerOwner(GameProfile p_213199_1_);
 
+   private Map<RegistryKey<World>, long[]> perWorldTickTimes = Maps.newIdentityHashMap();
+   @Nullable
+   public long[] getTickTime(RegistryKey<World> dim) {
+      return perWorldTickTimes.get(dim);
+   }
+
+   @Deprecated //Forge Internal use Only, You can screw up a lot of things if you mess with this map.
+   public synchronized Map<RegistryKey<World>, ServerWorld> forgeGetWorldMap() {
+      return this.levels;
+   }
+   private int worldArrayMarker = 0;
+   private int worldArrayLast = -1;
+   private ServerWorld[] worldArray;
+   @Deprecated //Forge Internal use Only, use to protect against concurrent modifications in the world tick loop.
+   public synchronized void markWorldsDirty() {
+      worldArrayMarker++;
+   }
+   private ServerWorld[] getWorldArray() {
+      if (worldArrayMarker == worldArrayLast && worldArray != null)
+         return worldArray;
+      worldArray = this.levels.values().stream().toArray(x -> new ServerWorld[x]);
+      worldArrayLast = worldArrayMarker;
+      return worldArray;
+   }
+
    public void saveDebugReport(Path p_223711_1_) throws IOException {
       Path path = p_223711_1_.resolve("levels");
 
@@ -1570,6 +_,10 @@
       return this.worldData;
    }
 
+   public DataPackRegistries getDataPackRegistries() {
+       return resources;
+   }
+
    public DynamicRegistries registryAccess() {
       return this.registryHolder;
    }
@@ -1578,4 +_,99 @@
    public IChatFilter createTextFilterForPlayer(ServerPlayerEntity p_244435_1_) {
       return null;
    }
+
+   @Override
+   public boolean isSameThread() {
+      return super.isSameThread() || this.isStopped();
+   }
+
+   // CraftBukkit start
+   public boolean isDebugging() {
+      return false;
+   }
+
+   public static MinecraftServer getServer() {
+      return (Bukkit.getServer() instanceof CraftServer) ? ((CraftServer) Bukkit.getServer()).getServer() : null;
+   }
+   // CraftBukkit end
+
+   public void initWorld(ServerWorld serverWorld, IServerWorldInfo worldInfo, IServerConfiguration saveData, DimensionGeneratorSettings generatorSettings) {
+      boolean flag = generatorSettings.isDebug();
+      if (serverWorld.generator != null) {
+         serverWorld.getWorld().getPopulators().addAll(serverWorld.generator.getDefaultPopulators(serverWorld.getWorld()));
+      }
+      WorldBorder worldborder = serverWorld.getWorldBorder();
+      worldborder.applySettings(worldInfo.getWorldBorder());
+      if (!worldInfo.isInitialized()) {
+         try {
+            setInitialSpawn(serverWorld, worldInfo, generatorSettings.generateBonusChest(), flag, true);
+            worldInfo.setInitialized(true);
+            if (flag) {
+               this.setupDebugLevel(this.worldData);
+            }
+         } catch (Throwable throwable) {
+            CrashReport crashreport = CrashReport.forThrowable(throwable, "Exception initializing level");
+            try {
+               serverWorld.fillReportDetails(crashreport);
+            } catch (Throwable throwable2) {
+               // empty catch block
+            }
+            throw new ReportedException(crashreport);
+         }
+         worldInfo.setInitialized(true);
+      }
+   }
+
+   public void loadSpawn(IChunkStatusListener listener, ServerWorld serverWorld) {
+      this.markWorldsDirty();
+      // CatServer start - Fix Multiverse-Core plugin
+      if (!serverWorld.isBukkitWorld) {
+         try {
+            File bukkitWorldDir = new File(overworld().convertable.getWorldDir().toFile(), storageSource.getLevelId());
+            if (!bukkitWorldDir.exists()) {
+               bukkitWorldDir.mkdir(); // Create empty dir to bypass Multiverse-Core check
+            }
+         } catch (Exception e) {
+            System.out.println(e.toString());
+         }
+      }
+      // CatServer end
+      Bukkit.getPluginManager().callEvent(new WorldInitEvent(serverWorld.getWorld()));
+      Bukkit.getPluginManager().callEvent(new WorldLoadEvent(serverWorld.getWorld()));
+      MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.world.WorldEvent.Load(serverWorld));
+      if (!serverWorld.getWorld().getKeepSpawnInMemory()) {
+         return;
+      }
+      this.forceTicks = true;
+      LOGGER.info("Preparing start region for dimension {}", (Object)serverWorld.dimension().location());
+      BlockPos blockpos = serverWorld.getSharedSpawnPos();
+      listener.updateSpawnPos(new ChunkPos(blockpos));
+      ServerChunkProvider serverchunkprovider = serverWorld.getChunkSource();
+      serverchunkprovider.getLightEngine().setTaskPerBatch(500);
+      this.nextTickTime = Util.getMillis();
+      serverchunkprovider.addRegionTicket(TicketType.START, new ChunkPos(blockpos), 11, Unit.INSTANCE);
+
+      while (serverchunkprovider.getTickingGenerated() < 441) {
+         this.executeModerately();
+      }
+
+      this.executeModerately();
+
+      ForcedChunksSaveData forcedchunkssavedata = serverWorld.getDataStorage().get(ForcedChunksSaveData::new, "chunks");
+      if (forcedchunkssavedata != null) {
+         LongIterator longiterator = forcedchunkssavedata.getChunks().iterator();
+
+         while (longiterator.hasNext()) {
+            long i = longiterator.nextLong();
+            ChunkPos chunkpos = new ChunkPos(i);
+            serverWorld.getChunkSource().updateChunkForced(chunkpos, true);
+         }
+      }
+      this.executeModerately();
+      listener.stop();
+      serverchunkprovider.getLightEngine().setTaskPerBatch(5);
+      this.updateMobSpawningFlags();
+      this.forceTicks = false;
+   }
+
 }
