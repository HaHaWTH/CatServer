--- a/net/minecraft/entity/item/BoatEntity.java
+++ b/net/minecraft/entity/item/BoatEntity.java
@@ -47,6 +_,13 @@
 import net.minecraft.world.World;
 import net.minecraftforge.api.distmarker.Dist;
 import net.minecraftforge.api.distmarker.OnlyIn;
+import org.bukkit.Location;
+import org.bukkit.entity.Vehicle;
+import org.bukkit.event.vehicle.VehicleDamageEvent;
+import org.bukkit.event.vehicle.VehicleDestroyEvent;
+import org.bukkit.event.vehicle.VehicleEntityCollisionEvent;
+import org.bukkit.event.vehicle.VehicleMoveEvent;
+import org.bukkit.event.vehicle.VehicleUpdateEvent;
 
 public class BoatEntity extends Entity {
    private static final DataParameter<Integer> DATA_ID_HURT = EntityDataManager.defineId(BoatEntity.class, DataSerializers.INT);
@@ -81,6 +_,14 @@
    private float bubbleAngle;
    private float bubbleAngleO;
 
+   // CraftBukkit start
+   public double maxSpeed;
+   public double occupiedDeceleration;
+   public double unoccupiedDeceleration;
+   public boolean landBoats;
+   private Location lastLocation;
+   // CraftBukkit end
+
    public BoatEntity(EntityType<? extends BoatEntity> p_i50129_1_, World p_i50129_2_) {
       super(p_i50129_1_, p_i50129_2_);
       this.blocksBuilding = true;
@@ -141,12 +_,33 @@
       if (this.isInvulnerableTo(p_70097_1_)) {
          return false;
       } else if (!this.level.isClientSide && !this.removed) {
+         // CraftBukkit start
+         Vehicle vehicle = (Vehicle) this.getBukkitEntity();
+         org.bukkit.entity.Entity attacker = (p_70097_1_.getEntity() == null) ? null : p_70097_1_.getEntity().getBukkitEntity();
+
+         VehicleDamageEvent event = new VehicleDamageEvent(vehicle, attacker, (double) p_70097_2_);
+         this.level.getCBServer().getPluginManager().callEvent(event);
+
+         if(event.isCancelled()){
+            return false;
+         }
+         // CraftBukkit end
          this.setHurtDir(-this.getHurtDir());
          this.setHurtTime(10);
          this.setDamage(this.getDamage() + p_70097_2_ * 10.0F);
          this.markHurt();
          boolean flag = p_70097_1_.getEntity() instanceof PlayerEntity && ((PlayerEntity)p_70097_1_.getEntity()).abilities.instabuild;
          if (flag || this.getDamage() > 40.0F) {
+               // CraftBukkit start
+               VehicleDestroyEvent destroyEvent = new VehicleDestroyEvent(vehicle, attacker);
+               this.level.getCBServer().getPluginManager().callEvent(destroyEvent);
+
+               if(destroyEvent.isCancelled()){
+                  this.setDamage(40F); // Maximize damage so this doesn't trigger again right away
+                  return true;
+               }
+               // CraftBukkit end
+
             if (!flag && this.level.getGameRules().getBoolean(GameRules.RULE_DOENTITYDROPS)) {
                this.spawnAtLocation(this.getDropItem());
             }
@@ -179,9 +_,29 @@
    public void push(Entity p_70108_1_) {
       if (p_70108_1_ instanceof BoatEntity) {
          if (p_70108_1_.getBoundingBox().minY < this.getBoundingBox().maxY) {
+            // CraftBukkit start
+            if(!this.isPassengerOfSameVehicle(p_70108_1_)) { // isSameVehicle == isRidingSameEntity maybe?
+               VehicleEntityCollisionEvent event = new VehicleEntityCollisionEvent((Vehicle) this.getBukkitEntity(), p_70108_1_.getBukkitEntity());
+               this.level.getCBServer().getPluginManager().callEvent(event);
+
+               if(event.isCancelled()){
+                  return;
+               }
+            }
+            // CraftBukkit end
             super.push(p_70108_1_);
          }
       } else if (p_70108_1_.getBoundingBox().minY <= this.getBoundingBox().minY) {
+         // CraftBukkit start
+         if(!this.isPassengerOfSameVehicle(p_70108_1_)) { // isSameVehicle == isRidingSameEntity maybe?
+            VehicleEntityCollisionEvent event = new VehicleEntityCollisionEvent((Vehicle) this.getBukkitEntity(), p_70108_1_.getBukkitEntity());
+            this.level.getCBServer().getPluginManager().callEvent(event);
+
+            if(event.isCancelled()){
+               return;
+            }
+         }
+         // CraftBukkit end
          super.push(p_70108_1_);
       }
 
@@ -269,6 +_,22 @@
          this.setDeltaMovement(Vector3d.ZERO);
       }
 
+      // CraftBukkit start
+      org.bukkit.Server server = this.level.getCBServer();
+      org.bukkit.World bworld = this.level.getWorld();
+
+      Location to = new Location(bworld, this.getX(), this.getY(), this.getZ(), this.yRot, this.xRot);
+      Vehicle vehicle = (Vehicle) this.getBukkitEntity();
+
+      server.getPluginManager().callEvent(new VehicleUpdateEvent(vehicle));
+
+      if (lastLocation != null && !lastLocation.equals(to)) {
+         VehicleMoveEvent event = new VehicleMoveEvent(vehicle, lastLocation, to);
+         server.getPluginManager().callEvent(event);
+      }
+      lastLocation = vehicle.getLocation();
+      // CraftBukkit end
+
       this.tickBubbleColumn();
 
       for(int i = 0; i <= 1; ++i) {
@@ -468,7 +_,7 @@
                      blockpos$mutable.set(l1, k2, i2);
                      BlockState blockstate = this.level.getBlockState(blockpos$mutable);
                      if (!(blockstate.getBlock() instanceof LilyPadBlock) && VoxelShapes.joinIsNotEmpty(blockstate.getCollisionShape(this.level, blockpos$mutable).move((double)l1, (double)k2, (double)i2), voxelshape, IBooleanFunction.AND)) {
-                        f += blockstate.getBlock().getFriction();
+                        f += blockstate.getSlipperiness(this.level, blockpos$mutable, this);
                         ++k1;
                      }
                   }
@@ -815,6 +_,17 @@
 
    public boolean isUnderWater() {
       return this.status == BoatEntity.Status.UNDER_WATER || this.status == BoatEntity.Status.UNDER_FLOWING_WATER;
+   }
+
+   // Forge: Fix MC-119811 by instantly completing lerp on board
+   @Override
+   protected boolean cBAddPassenger(Entity passenger) {
+      super.cBAddPassenger(passenger);
+      if (this.isControlledByLocalInstance() && this.lerpSteps > 0) {
+         this.lerpSteps = 0;
+         this.absMoveTo(this.lerpX, this.lerpY, this.lerpZ, (float)this.lerpYRot, (float)this.lerpXRot);
+      }
+      return false;
    }
 
    public static enum Status {
