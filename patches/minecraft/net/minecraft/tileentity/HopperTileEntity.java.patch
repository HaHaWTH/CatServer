--- a/net/minecraft/tileentity/HopperTileEntity.java
+++ b/net/minecraft/tileentity/HopperTileEntity.java
@@ -1,5 +_,7 @@
 package net.minecraft.tileentity;
 
+import catserver.server.inventory.CatCustomInventory;
+import catserver.server.inventory.CatInventoryUtils;
 import java.util.List;
 import java.util.function.Supplier;
 import java.util.stream.Collectors;
@@ -11,8 +_,10 @@
 import net.minecraft.block.HopperBlock;
 import net.minecraft.entity.Entity;
 import net.minecraft.entity.item.ItemEntity;
+import net.minecraft.entity.item.minecart.HopperMinecartEntity;
 import net.minecraft.entity.player.PlayerEntity;
 import net.minecraft.entity.player.PlayerInventory;
+import net.minecraft.inventory.DoubleSidedInventory;
 import net.minecraft.inventory.IInventory;
 import net.minecraft.inventory.ISidedInventory;
 import net.minecraft.inventory.ISidedInventoryProvider;
@@ -31,12 +_,54 @@
 import net.minecraft.util.text.ITextComponent;
 import net.minecraft.util.text.TranslationTextComponent;
 import net.minecraft.world.World;
+import org.bukkit.craftbukkit.v1_16_R3.entity.CraftHumanEntity;
+import org.bukkit.craftbukkit.v1_16_R3.inventory.CraftItemStack;
+import org.bukkit.entity.HumanEntity;
+import org.bukkit.event.inventory.InventoryMoveItemEvent;
+import org.bukkit.event.inventory.InventoryPickupItemEvent;
+import org.bukkit.inventory.Inventory;
+import org.bukkit.inventory.InventoryHolder;
 
 public class HopperTileEntity extends LockableLootTileEntity implements IHopper, ITickableTileEntity {
    private NonNullList<ItemStack> items = NonNullList.withSize(5, ItemStack.EMPTY);
    private int cooldownTime = -1;
    private long tickedGameTime;
 
+   // CraftBukkit start - add fields and methods
+   private int maxStack = MAX_STACK;
+   public List<HumanEntity> transaction = new java.util.ArrayList<HumanEntity>();
+
+   @Override
+   public int getMaxStackSize() {
+      return maxStack;
+   }
+
+   @Override
+   public List<ItemStack> getContents() {
+      return items;
+   }
+
+   @Override
+   public void onOpen(CraftHumanEntity who) {
+      this.transaction.add(who);
+   }
+
+   @Override
+   public void onClose(CraftHumanEntity who) {
+      this.transaction.remove(who);
+   }
+
+   @Override
+   public List<HumanEntity> getViewers() {
+      return this.transaction;
+   }
+
+   @Override
+   public void setMaxStackSize(int size) {
+      this.maxStack = size;
+   }
+   // CraftBukkit end
+
    public HopperTileEntity() {
       super(TileEntityType.HOPPER);
    }
@@ -89,9 +_,14 @@
          this.tickedGameTime = this.level.getGameTime();
          if (!this.isOnCooldown()) {
             this.setCooldown(0);
-            this.tryMoveItems(() -> {
+            // Spigot start
+            boolean result = this.tryMoveItems(() -> {
                return suckInItems(this);
             });
+            if (!result && this.level.spigotConfig.hopperCheck > 1) {
+               this.setCooldown(this.level.spigotConfig.hopperCheck);
+            }
+            // Spigot end
          }
 
       }
@@ -110,7 +_,7 @@
             }
 
             if (flag) {
-               this.setCooldown(8);
+               this.setCooldown(level.spigotConfig.hopperTransfer); // Spigot
                this.setChanged();
                return true;
             }
@@ -133,6 +_,7 @@
    }
 
    private boolean ejectItems() {
+      if (net.minecraftforge.items.VanillaInventoryCodeHooks.insertHook(this)) return true;
       IInventory iinventory = this.getAttachedContainer();
       if (iinventory == null) {
          return false;
@@ -144,12 +_,36 @@
             for(int i = 0; i < this.getContainerSize(); ++i) {
                if (!this.getItem(i).isEmpty()) {
                   ItemStack itemstack = this.getItem(i).copy();
-                  ItemStack itemstack1 = addItem(this, iinventory, this.removeItem(i, 1), direction);
+
+                  // CraftBukkit start - Call event when pushing items into other inventories
+                  CraftItemStack oitemstack = CraftItemStack.asCraftMirror(this.removeItem(i, level.spigotConfig.hopperAmount)); // Spigot
+                  Inventory destinationInventory;
+                  // Have to special case large chests as they work oddly
+                  if (iinventory instanceof DoubleSidedInventory) {
+                     destinationInventory = new org.bukkit.craftbukkit.v1_16_R3.inventory.CraftInventoryDoubleChest((DoubleSidedInventory) iinventory);
+                  } else {
+                     destinationInventory = CatInventoryUtils.getBukkitInventory(iinventory);
+                  }
+                  InventoryHolder owner = CatInventoryUtils.getOwner((TileEntity) this);
+                  Inventory hopperOwner = (owner != null ? owner.getInventory() : new CatCustomInventory(this).getInventory());
+                  InventoryMoveItemEvent event = new InventoryMoveItemEvent(hopperOwner, oitemstack.clone(), destinationInventory, true);
+                  // LoliServer end
+                  this.getLevel().getCBServer().getPluginManager().callEvent(event);
+                  if (event.isCancelled()) {
+                     this.setItem(i, itemstack);
+                     this.setCooldown(level.spigotConfig.hopperTransfer); // Spigot
+                     return false;
+                  }
+                  int origCount = event.getItem().getAmount(); // Spigot
+                  ItemStack itemstack1 = addItem(this, iinventory, CraftItemStack.asNMSCopy(event.getItem()), direction);
+                  // CraftBukkit end
+
                   if (itemstack1.isEmpty()) {
                      iinventory.setChanged();
                      return true;
                   }
 
+                  itemstack.shrink(origCount - itemstack1.getCount()); // Spigot
                   this.setItem(i, itemstack);
                }
             }
@@ -177,6 +_,8 @@
    }
 
    public static boolean suckInItems(IHopper p_145891_0_) {
+      Boolean ret = net.minecraftforge.items.VanillaInventoryCodeHooks.extractHook(p_145891_0_);
+      if (ret != null) return ret;
       IInventory iinventory = getSourceContainer(p_145891_0_);
       if (iinventory != null) {
          Direction direction = Direction.DOWN;
@@ -198,12 +_,57 @@
       ItemStack itemstack = p_174915_1_.getItem(p_174915_2_);
       if (!itemstack.isEmpty() && canTakeItemFromContainer(p_174915_1_, itemstack, p_174915_2_, p_174915_3_)) {
          ItemStack itemstack1 = itemstack.copy();
-         ItemStack itemstack2 = addItem(p_174915_1_, p_174915_0_, p_174915_1_.removeItem(p_174915_2_, 1), (Direction)null);
+
+         // CatServer start - Optimized of call event on collection of items from inventories into the hopper
+         ItemStack originNMSStack = p_174915_1_.removeItem(p_174915_2_, p_174915_0_.getLevel().spigotConfig.hopperAmount);
+         ItemStack resultNMSStack = originNMSStack;
+
+         InventoryHolder owner = CatInventoryUtils.getOwner(p_174915_0_);
+         Inventory hopperOwner = (owner != null ? owner.getInventory() : new CatCustomInventory(p_174915_0_).getInventory());
+
+         InventoryMoveItemEvent event = null;
+         if (true /*!TileEntityHopper.skipHopperEvents*/) {
+            CraftItemStack oitemstack = CraftItemStack.asCraftMirror(originNMSStack);
+
+            Inventory sourceInventory;
+            // Have to special case large chests as they work oddly
+            if (p_174915_1_ instanceof DoubleSidedInventory) {
+               sourceInventory = new org.bukkit.craftbukkit.v1_16_R3.inventory.CraftInventoryDoubleChest((DoubleSidedInventory) p_174915_1_);
+            } else {
+               sourceInventory = CatInventoryUtils.getOwner(p_174915_1_).getInventory();
+            }
+
+            if (sourceInventory != null) {
+               event = new InventoryMoveItemEvent(sourceInventory, oitemstack, hopperOwner, false);
+               p_174915_0_.getLevel().getCBServer().getPluginManager().callEvent(event);
+
+               if (event.isCancelled()) {
+                  p_174915_1_.setItem(p_174915_2_, itemstack1);
+                  if (p_174915_0_ instanceof HopperTileEntity) {
+                     ((HopperTileEntity) p_174915_0_).setCooldown(p_174915_0_.getLevel().spigotConfig.hopperTransfer); // Spigot
+                  } else if (p_174915_0_ instanceof HopperMinecartEntity) {
+                     ((HopperMinecartEntity) p_174915_0_).setCooldown(p_174915_0_.getLevel().spigotConfig.hopperTransfer / 2); // Spigot
+                  }
+                  return false;
+               }
+            }
+
+            if (event.isCallSetItem) resultNMSStack = CraftItemStack.asNMSCopy(event.getRawItem());
+         }
+         int origCount = resultNMSStack.getCount();
+         ItemStack itemstack2 = addItem(p_174915_1_, p_174915_0_, resultNMSStack, null);
+         // CatServer end
+
          if (itemstack2.isEmpty()) {
-            p_174915_1_.setChanged();
+            if (event == null || !event.isCallSetItem || ItemStack.matches(resultNMSStack, originNMSStack)) {
+               p_174915_1_.setChanged();
+            } else {
+               p_174915_1_.setItem(p_174915_2_, itemstack1);
+            }
             return true;
          }
 
+         itemstack1.shrink(origCount - itemstack2.getCount()); // Spigot
          p_174915_1_.setItem(p_174915_2_, itemstack1);
       }
 
@@ -212,6 +_,15 @@
 
    public static boolean addItem(IInventory p_200114_0_, ItemEntity p_200114_1_) {
       boolean flag = false;
+      // CraftBukkit start
+      InventoryHolder owner = CatInventoryUtils.getOwner(p_200114_0_);
+      Inventory sourceInventory = owner != null ? owner.getInventory() : new CatCustomInventory(p_200114_0_).getInventory();
+      InventoryPickupItemEvent event = new InventoryPickupItemEvent(sourceInventory, (org.bukkit.entity.Item) p_200114_1_.getBukkitEntity());
+      p_200114_1_.level.getCBServer().getPluginManager().callEvent(event);
+      if (event.isCancelled()) {
+         return false;
+      }
+      // CraftBukkit end
       ItemStack itemstack = p_200114_1_.getItem().copy();
       ItemStack itemstack1 = addItem((IInventory)null, p_200114_0_, itemstack, (Direction)null);
       if (itemstack1.isEmpty()) {
@@ -284,7 +_,7 @@
                      }
                   }
 
-                  hoppertileentity1.setCooldown(8 - k);
+                  hoppertileentity1.setCooldown(hoppertileentity1.level.spigotConfig.hopperTransfer - k); // Spigot
                }
             }
 
@@ -322,10 +_,11 @@
       IInventory iinventory = null;
       BlockPos blockpos = new BlockPos(p_145893_1_, p_145893_3_, p_145893_5_);
       BlockState blockstate = p_145893_0_.getBlockState(blockpos);
+      if ( !p_145893_0_.hasChunkAt( blockpos ) ) return null; // Spigot
       Block block = blockstate.getBlock();
       if (block instanceof ISidedInventoryProvider) {
          iinventory = ((ISidedInventoryProvider)block).getContainer(blockstate, p_145893_0_, blockpos);
-      } else if (block.isEntityBlock()) {
+      } else if (blockstate.hasTileEntity()) {
          TileEntity tileentity = p_145893_0_.getBlockEntity(blockpos);
          if (tileentity instanceof IInventory) {
             iinventory = (IInventory)tileentity;
@@ -403,5 +_,14 @@
 
    protected Container createMenu(int p_213906_1_, PlayerInventory p_213906_2_) {
       return new HopperContainer(p_213906_1_, p_213906_2_, this);
+   }
+
+   @Override
+   protected net.minecraftforge.items.IItemHandler createUnSidedHandler() {
+      return new net.minecraftforge.items.VanillaHopperItemHandler(this);
+   }
+
+   public long getLastUpdateTime() {
+      return this.tickedGameTime;
    }
 }
