--- a/net/minecraft/tileentity/AbstractFurnaceTileEntity.java
+++ b/net/minecraft/tileentity/AbstractFurnaceTileEntity.java
@@ -6,6 +_,8 @@
 import it.unimi.dsi.fastutil.objects.Object2IntMap.Entry;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
 import javax.annotation.Nullable;
 import net.minecraft.block.AbstractFurnaceBlock;
 import net.minecraft.block.BlockState;
@@ -36,16 +_,55 @@
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.util.math.vector.Vector3d;
 import net.minecraft.world.World;
+import org.bukkit.craftbukkit.v1_16_R3.block.CraftBlock;
+import org.bukkit.craftbukkit.v1_16_R3.entity.CraftHumanEntity;
+import org.bukkit.craftbukkit.v1_16_R3.inventory.CraftItemStack;
+import org.bukkit.entity.HumanEntity;
+import org.bukkit.entity.Player;
+import org.bukkit.event.inventory.FurnaceBurnEvent;
+import org.bukkit.event.inventory.FurnaceExtractEvent;
+import org.bukkit.event.inventory.FurnaceSmeltEvent;
 
 public abstract class AbstractFurnaceTileEntity extends LockableTileEntity implements ISidedInventory, IRecipeHolder, IRecipeHelperPopulator, ITickableTileEntity {
    private static final int[] SLOTS_FOR_UP = new int[]{0};
    private static final int[] SLOTS_FOR_DOWN = new int[]{2, 1};
    private static final int[] SLOTS_FOR_SIDES = new int[]{1};
    protected NonNullList<ItemStack> items = NonNullList.withSize(3, ItemStack.EMPTY);
-   private int litTime;
+   public int litTime;
    private int litDuration;
-   private int cookingProgress;
-   private int cookingTotalTime;
+   public int cookingProgress;
+   public int cookingTotalTime;
+
+   // CraftBukkit start - add fields and methods
+   private int maxStack = MAX_STACK;
+   public List<HumanEntity> transaction = new java.util.ArrayList<HumanEntity>();
+
+   public List<ItemStack> getContents() {
+      return this.items;
+   }
+
+   public void onOpen(CraftHumanEntity who) {
+      transaction.add(who);
+   }
+
+   public void onClose(CraftHumanEntity who) {
+      transaction.remove(who);
+   }
+
+   public List<HumanEntity> getViewers() {
+      return transaction;
+   }
+
+   @Override
+   public int getMaxStackSize() {
+      return maxStack;
+   }
+
+   public void setMaxStackSize(int size) {
+      maxStack = size;
+   }
+   // CraftBukkit end
+
    protected final IIntArray dataAccess = new IIntArray() {
       public int get(int p_221476_1_) {
          switch(p_221476_1_) {
@@ -91,6 +_,7 @@
       this.recipeType = p_i49964_2_;
    }
 
+   @Deprecated //Forge - get burn times by calling ForgeHooks#getBurnTime(ItemStack)
    public static Map<Item, Integer> getFuel() {
       Map<Item, Integer> map = Maps.newLinkedHashMap();
       add(map, Items.LAVA_BUCKET, 20000);
@@ -184,13 +_,13 @@
       return this.litTime > 0;
    }
 
-   public void load(BlockState p_230337_1_, CompoundNBT p_230337_2_) {
+   public void load(BlockState p_230337_1_, CompoundNBT p_230337_2_) { //TODO: MARK
       super.load(p_230337_1_, p_230337_2_);
       this.items = NonNullList.withSize(this.getContainerSize(), ItemStack.EMPTY);
       ItemStackHelper.loadAllItems(p_230337_2_, this.items);
-      this.litTime = p_230337_2_.getShort("BurnTime");
-      this.cookingProgress = p_230337_2_.getShort("CookTime");
-      this.cookingTotalTime = p_230337_2_.getShort("CookTimeTotal");
+      this.litTime = p_230337_2_.getInt("BurnTime");
+      this.cookingProgress = p_230337_2_.getInt("CookTime");
+      this.cookingTotalTime = p_230337_2_.getInt("CookTimeTotal");
       this.litDuration = this.getBurnDuration(this.items.get(1));
       CompoundNBT compoundnbt = p_230337_2_.getCompound("RecipesUsed");
 
@@ -202,9 +_,9 @@
 
    public CompoundNBT save(CompoundNBT p_189515_1_) {
       super.save(p_189515_1_);
-      p_189515_1_.putShort("BurnTime", (short)this.litTime);
-      p_189515_1_.putShort("CookTime", (short)this.cookingProgress);
-      p_189515_1_.putShort("CookTimeTotal", (short)this.cookingTotalTime);
+      p_189515_1_.putInt("BurnTime", this.litTime);
+      p_189515_1_.putInt("CookTime", this.cookingProgress);
+      p_189515_1_.putInt("CookTimeTotal", this.cookingTotalTime);
       ItemStackHelper.saveAllItems(p_189515_1_, this.items);
       CompoundNBT compoundnbt = new CompoundNBT();
       this.recipesUsed.forEach((p_235643_1_, p_235643_2_) -> {
@@ -226,16 +_,26 @@
          if (this.isLit() || !itemstack.isEmpty() && !this.items.get(0).isEmpty()) {
             IRecipe<?> irecipe = this.level.getRecipeManager().getRecipeFor((IRecipeType<AbstractCookingRecipe>)this.recipeType, this, this.level).orElse(null);
             if (!this.isLit() && this.canBurn(irecipe)) {
-               this.litTime = this.getBurnDuration(itemstack);
+               // CraftBukkit start
+               CraftItemStack fuel = CraftItemStack.asCraftMirror(itemstack);
+               FurnaceBurnEvent furnaceBurnEvent = new FurnaceBurnEvent(CraftBlock.at(this.level, this.worldPosition), fuel, this.getBurnDuration(itemstack));
+               this.level.getCBServer().getPluginManager().callEvent(furnaceBurnEvent);
+               if (furnaceBurnEvent.isCancelled()) {
+                  return;
+               }
+               this.litTime = furnaceBurnEvent.getBurnTime();
                this.litDuration = this.litTime;
-               if (this.isLit()) {
+               if (this.isLit() && furnaceBurnEvent.isBurning()) {
+                  // CraftBukkit end
                   flag1 = true;
+                  if (itemstack.hasContainerItem())
+                      this.items.set(1, itemstack.getContainerItem());
+                  else
                   if (!itemstack.isEmpty()) {
                      Item item = itemstack.getItem();
                      itemstack.shrink(1);
                      if (itemstack.isEmpty()) {
-                        Item item1 = item.getCraftingRemainingItem();
-                        this.items.set(1, item1 == null ? ItemStack.EMPTY : new ItemStack(item1));
+                        this.items.set(1, itemstack.getContainerItem());
                      }
                   }
                }
@@ -270,7 +_,7 @@
 
    protected boolean canBurn(@Nullable IRecipe<?> p_214008_1_) {
       if (!this.items.get(0).isEmpty() && p_214008_1_ != null) {
-         ItemStack itemstack = p_214008_1_.getResultItem();
+         ItemStack itemstack = ((IRecipe<ISidedInventory>) p_214008_1_).assemble(this);
          if (itemstack.isEmpty()) {
             return false;
          } else {
@@ -279,10 +_,10 @@
                return true;
             } else if (!itemstack1.sameItem(itemstack)) {
                return false;
-            } else if (itemstack1.getCount() < this.getMaxStackSize() && itemstack1.getCount() < itemstack1.getMaxStackSize()) {
+            } else if (itemstack1.getCount() + itemstack.getCount() <= this.getMaxStackSize() && itemstack1.getCount() + itemstack.getCount() <= itemstack1.getMaxStackSize()) { // Forge fix: make furnace respect stack sizes in furnace recipes
                return true;
             } else {
-               return itemstack1.getCount() < itemstack.getMaxStackSize();
+               return itemstack1.getCount() + itemstack.getCount() <= itemstack.getMaxStackSize(); // Forge fix: make furnace respect stack sizes in furnace recipes
             }
          }
       } else {
@@ -293,12 +_,27 @@
    private void burn(@Nullable IRecipe<?> p_214007_1_) {
       if (p_214007_1_ != null && this.canBurn(p_214007_1_)) {
          ItemStack itemstack = this.items.get(0);
-         ItemStack itemstack1 = p_214007_1_.getResultItem();
+         ItemStack itemstack1 = ((IRecipe<ISidedInventory>) p_214007_1_).assemble(this);
          ItemStack itemstack2 = this.items.get(2);
-         if (itemstack2.isEmpty()) {
-            this.items.set(2, itemstack1.copy());
-         } else if (itemstack2.getItem() == itemstack1.getItem()) {
-            itemstack2.grow(1);
+
+         // CraftBukkit start - fire FurnaceSmeltEvent
+         CraftItemStack source = CraftItemStack.asCraftMirror(itemstack);
+         org.bukkit.inventory.ItemStack result = CraftItemStack.asBukkitCopy(itemstack1);
+         FurnaceSmeltEvent furnaceSmeltEvent = new FurnaceSmeltEvent(this.level.getWorld().getBlockAt(worldPosition.getX(), worldPosition.getY(), worldPosition.getZ()), source, result);
+         this.level.getCBServer().getPluginManager().callEvent(furnaceSmeltEvent);
+         if (furnaceSmeltEvent.isCancelled()) {
+            return;
+         }
+         result = furnaceSmeltEvent.getResult();
+         itemstack1 = CraftItemStack.asNMSCopy(result);
+         if (!itemstack1.isEmpty()) {
+            if (itemstack2.isEmpty()) {
+               this.items.set(2, itemstack1.copy());
+            } else if (CraftItemStack.asCraftMirror(itemstack2).isSimilar(result)) {
+               itemstack2.grow(itemstack1.getCount());
+            } else {
+               return;
+            }
          }
 
          if (!this.level.isClientSide) {
@@ -318,7 +_,7 @@
          return 0;
       } else {
          Item item = p_213997_1_.getItem();
-         return getFuel().getOrDefault(item, 0);
+         return net.minecraftforge.common.ForgeHooks.getBurnTime(p_213997_1_, this.recipeType);
       }
    }
 
@@ -327,7 +_,7 @@
    }
 
    public static boolean isFuel(ItemStack p_213991_0_) {
-      return getFuel().containsKey(p_213991_0_.getItem());
+      return net.minecraftforge.common.ForgeHooks.getBurnTime(p_213991_0_, null) > 0;
    }
 
    public int[] getSlotsForFace(Direction p_180463_1_) {
@@ -410,7 +_,7 @@
          return true;
       } else {
          ItemStack itemstack = this.items.get(1);
-         return isFuel(p_94041_2_) || p_94041_2_.getItem() == Items.BUCKET && itemstack.getItem() != Items.BUCKET;
+         return net.minecraftforge.common.ForgeHooks.getBurnTime(p_94041_2_, this.recipeType) > 0 || p_94041_2_.getItem() == Items.BUCKET && itemstack.getItem() != Items.BUCKET;
       }
    }
 
@@ -434,32 +_,52 @@
    public void awardUsedRecipes(PlayerEntity p_201560_1_) {
    }
 
+   // CatServer start - Fix MCAR mod compatibility
+   public AtomicReference<PlayerEntity> catserver$awardPlayerEntity = new AtomicReference<>();
+   public AtomicReference<ItemStack> catserver$awardItemStack = new AtomicReference<>();
+   public AtomicInteger catserver$awardAmount = new AtomicInteger();
+
    public void awardUsedRecipesAndPopExperience(PlayerEntity p_235645_1_) {
-      List<IRecipe<?>> list = this.getRecipesToAwardAndPopExperience(p_235645_1_.level, p_235645_1_.position());
+      List<IRecipe<?>> list = this.getRecipesToAwardAndPopExperience(p_235645_1_.level, p_235645_1_.position()); // TODO
       p_235645_1_.awardRecipes(list);
       this.recipesUsed.clear();
    }
 
+   public void unlockRecipes(PlayerEntity p_235645_1_, ItemStack itemstack, int amount) { // CraftBukkit
+      this.catserver$awardPlayerEntity.set(p_235645_1_);
+      this.catserver$awardItemStack.set(itemstack);
+      this.catserver$awardAmount.set(amount);
+      this.awardUsedRecipesAndPopExperience(p_235645_1_);
+   }
+
    public List<IRecipe<?>> getRecipesToAwardAndPopExperience(World p_235640_1_, Vector3d p_235640_2_) {
       List<IRecipe<?>> list = Lists.newArrayList();
 
       for(Entry<ResourceLocation> entry : this.recipesUsed.object2IntEntrySet()) {
          p_235640_1_.getRecipeManager().byKey(entry.getKey()).ifPresent((p_235642_4_) -> {
             list.add(p_235642_4_);
-            createExperience(p_235640_1_, p_235640_2_, entry.getIntValue(), ((AbstractCookingRecipe)p_235642_4_).getExperience());
+            createExperience(p_235640_1_, p_235640_2_, entry.getIntValue(), ((AbstractCookingRecipe) p_235642_4_).getExperience(), catserver$awardPlayerEntity.getAndSet(null), catserver$awardItemStack.getAndSet(null), catserver$awardAmount.getAndSet(0)); // CatServer
          });
       }
 
       return list;
    }
 
-   private static void createExperience(World p_235641_0_, Vector3d p_235641_1_, int p_235641_2_, float p_235641_3_) {
+   private void createExperience(World p_235641_0_, Vector3d p_235641_1_, int p_235641_2_, float p_235641_3_, PlayerEntity entityhuman, ItemStack itemstack, int amount) {
       int i = MathHelper.floor((float)p_235641_2_ * p_235641_3_);
       float f = MathHelper.frac((float)p_235641_2_ * p_235641_3_);
       if (f != 0.0F && Math.random() < (double)f) {
          ++i;
       }
 
+      // CraftBukkit start - fire FurnaceExtractEvent
+      if (amount != 0) {
+         FurnaceExtractEvent event = new FurnaceExtractEvent((Player) entityhuman.getBukkitEntity(), CraftBlock.at(p_235641_0_, this.worldPosition), org.bukkit.craftbukkit.v1_16_R3.util.CraftMagicNumbers.getMaterial(itemstack.getItem()), amount, i);
+         p_235641_0_.getCBServer().getPluginManager().callEvent(event);
+         i = event.getExpToDrop();
+      }
+      // CraftBukkit end
+
       while(i > 0) {
          int j = ExperienceOrbEntity.getExperienceValue(i);
          i -= j;
@@ -467,11 +_,35 @@
       }
 
    }
+   // CatServer end
 
    public void fillStackedContents(RecipeItemHelper p_194018_1_) {
       for(ItemStack itemstack : this.items) {
          p_194018_1_.accountStack(itemstack);
       }
 
+   }
+
+   net.minecraftforge.common.util.LazyOptional<? extends net.minecraftforge.items.IItemHandler>[] handlers =
+           net.minecraftforge.items.wrapper.SidedInvWrapper.create(this, Direction.UP, Direction.DOWN, Direction.NORTH);
+
+   @Override
+   public <T> net.minecraftforge.common.util.LazyOptional<T> getCapability(net.minecraftforge.common.capabilities.Capability<T> capability, @Nullable Direction facing) {
+      if (!this.remove && facing != null && capability == net.minecraftforge.items.CapabilityItemHandler.ITEM_HANDLER_CAPABILITY) {
+         if (facing == Direction.UP)
+            return handlers[0].cast();
+         else if (facing == Direction.DOWN)
+            return handlers[1].cast();
+         else
+            return handlers[2].cast();
+      }
+      return super.getCapability(capability, facing);
+   }
+
+   @Override
+   protected void invalidateCaps() {
+      super.invalidateCaps();
+      for (int x = 0; x < handlers.length; x++)
+        handlers[x].invalidate();
    }
 }
