--- a/net/minecraft/tileentity/BeaconTileEntity.java
+++ b/net/minecraft/tileentity/BeaconTileEntity.java
@@ -3,6 +_,7 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
 import java.util.Arrays;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
 import java.util.stream.Collectors;
@@ -11,7 +_,6 @@
 import net.minecraft.block.Block;
 import net.minecraft.block.BlockState;
 import net.minecraft.block.Blocks;
-import net.minecraft.block.IBeaconBeamColorProvider;
 import net.minecraft.entity.player.PlayerEntity;
 import net.minecraft.entity.player.PlayerInventory;
 import net.minecraft.entity.player.ServerPlayerEntity;
@@ -37,21 +_,24 @@
 import net.minecraft.world.gen.Heightmap;
 import net.minecraftforge.api.distmarker.Dist;
 import net.minecraftforge.api.distmarker.OnlyIn;
+import org.bukkit.craftbukkit.v1_16_R3.potion.CraftPotionUtil;
+import org.bukkit.event.entity.EntityPotionEffectEvent;
+import org.bukkit.potion.PotionEffect;
 
 public class BeaconTileEntity extends TileEntity implements INamedContainerProvider, ITickableTileEntity {
    public static final Effect[][] BEACON_EFFECTS = new Effect[][]{{Effects.MOVEMENT_SPEED, Effects.DIG_SPEED}, {Effects.DAMAGE_RESISTANCE, Effects.JUMP}, {Effects.DAMAGE_BOOST}, {Effects.REGENERATION}};
    private static final Set<Effect> VALID_EFFECTS = Arrays.stream(BEACON_EFFECTS).flatMap(Arrays::stream).collect(Collectors.toSet());
    private List<BeaconTileEntity.BeamSegment> beamSections = Lists.newArrayList();
    private List<BeaconTileEntity.BeamSegment> checkingBeamSections = Lists.newArrayList();
-   private int levels;
+   public int levels; // private->public CraftBukkit
    private int lastCheckY = -1;
    @Nullable
-   private Effect primaryPower;
-   @Nullable
-   private Effect secondaryPower;
-   @Nullable
-   private ITextComponent name;
-   private LockCode lockKey = LockCode.NO_LOCK;
+   public Effect primaryPower; // private->public CraftBukkit
+   @Nullable
+   public Effect secondaryPower; // private->public CraftBukkit
+   @Nullable
+   public ITextComponent name; // private->public CraftBukkit
+   public LockCode lockKey = LockCode.NO_LOCK; // private->public CraftBukkit
    private final IIntArray dataAccess = new IIntArray() {
       public int get(int p_221476_1_) {
          switch(p_221476_1_) {
@@ -89,6 +_,16 @@
       }
    };
 
+   // CraftBukkit start - add fields and methods
+   public PotionEffect getPrimaryEffect() {
+      return (this.primaryPower != null) ? CraftPotionUtil.toBukkit(new EffectInstance(this.primaryPower, getLevelCB(), getAmplification(), true, true)) : null;
+   }
+
+   public PotionEffect getSecondaryEffect() {
+      return (hasSecondaryEffect()) ? CraftPotionUtil.toBukkit(new EffectInstance(this.secondaryPower, getLevelCB(), getAmplification(), true, true)) : null;
+   }
+   // CraftBukkit end
+
    public BeaconTileEntity() {
       super(TileEntityType.BEACON);
    }
@@ -112,8 +_,8 @@
       for(int i1 = 0; i1 < 10 && blockpos.getY() <= l; ++i1) {
          BlockState blockstate = this.level.getBlockState(blockpos);
          Block block = blockstate.getBlock();
-         if (block instanceof IBeaconBeamColorProvider) {
-            float[] afloat = ((IBeaconBeamColorProvider)block).getColor().getTextureDiffuseColors();
+         float[] afloat = blockstate.getBeaconColorMultiplier(this.level, blockpos, getBlockPos());
+         if (afloat != null) {
             if (this.checkingBeamSections.size() <= 1) {
                beacontileentity$beamsegment = new BeaconTileEntity.BeamSegment(afloat);
                this.checkingBeamSections.add(beacontileentity$beamsegment);
@@ -203,30 +_,65 @@
       super.setRemoved();
    }
 
+   // CraftBukkit start - split into components
+   private byte getAmplification() {
+      byte b0 = 0;
+      if (this.levels >= 4 && this.primaryPower == this.secondaryPower) {
+         b0 = 1;
+      }
+      return b0;
+   }
+
+   private int getLevelCB() {
+      int i = (9 + this.levels * 2) * 20;
+      return i;
+   }
+   // CraftBukkit end
+
+   public List getHumansInRange() {
+      double d0 = this.levels * 10 + 10;
+      AxisAlignedBB axisalignedbb = new AxisAlignedBB(this.worldPosition).inflate(d0).expandTowards(0.0, this.level.getMaxBuildHeight(), 0.0);
+      List<PlayerEntity> list = this.level.getEntitiesOfClass(PlayerEntity.class, axisalignedbb);
+      return list;
+   }
+
+   private void applyEffect(List<PlayerEntity> list, final Effect effects, final int i, final int b0) {
+      Iterator iterator = list.iterator();
+
+      PlayerEntity entityhuman;
+
+      while (iterator.hasNext()) {
+         entityhuman = (PlayerEntity) iterator.next();
+         entityhuman.addEffect(new EffectInstance(effects, i, b0, true, true), EntityPotionEffectEvent.Cause.BEACON);
+      }
+   }
+
+   private boolean hasSecondaryEffect() {
+      if (this.levels >= 4 && this.primaryPower != this.secondaryPower && this.secondaryPower != null) {
+         return true;
+      }
+
+      return false;
+   }
+
    private void applyEffects() {
       if (!this.level.isClientSide && this.primaryPower != null) {
          double d0 = (double)(this.levels * 10 + 10);
-         int i = 0;
-         if (this.levels >= 4 && this.primaryPower == this.secondaryPower) {
-            i = 1;
-         }
+         byte b0 = getAmplification();
+         int i = getLevelCB();
 
          int j = (9 + this.levels * 2) * 20;
-         AxisAlignedBB axisalignedbb = (new AxisAlignedBB(this.worldPosition)).inflate(d0).expandTowards(0.0D, (double)this.level.getMaxBuildHeight(), 0.0D);
-         List<PlayerEntity> list = this.level.getEntitiesOfClass(PlayerEntity.class, axisalignedbb);
-
-         for(PlayerEntity playerentity : list) {
-            playerentity.addEffect(new EffectInstance(this.primaryPower, j, i, true, true));
-         }
-
-         if (this.levels >= 4 && this.primaryPower != this.secondaryPower && this.secondaryPower != null) {
-            for(PlayerEntity playerentity1 : list) {
-               playerentity1.addEffect(new EffectInstance(this.secondaryPower, j, 0, true, true));
+         List<PlayerEntity> list = getHumansInRange();
+
+         applyEffect(list, this.primaryPower, i, b0);
+
+         if (hasSecondaryEffect()) {
+            applyEffect(list, this.secondaryPower, i, 0);
             }
          }
 
       }
-   }
+   // CraftBukkit end
 
    public void playSound(SoundEvent p_205736_1_) {
       this.level.playSound((PlayerEntity)null, this.worldPosition, p_205736_1_, SoundCategory.BLOCKS, 1.0F, 1.0F);
@@ -263,8 +_,11 @@
 
    public void load(BlockState p_230337_1_, CompoundNBT p_230337_2_) {
       super.load(p_230337_1_, p_230337_2_);
-      this.primaryPower = getValidEffectById(p_230337_2_.getInt("Primary"));
-      this.secondaryPower = getValidEffectById(p_230337_2_.getInt("Secondary"));
+      // CraftBukkit start - persist manually set non-default beacon effects (SPIGOT-3598)
+      this.primaryPower = Effect.byId(p_230337_2_.getInt("Primary"));
+      this.secondaryPower = Effect.byId(p_230337_2_.getInt("Secondary"));
+      this.levels = p_230337_2_.getInt("Levels"); // SPIGOT-5053, use where available
+      // CraftBukkit end
       if (p_230337_2_.contains("CustomName", 8)) {
          this.name = ITextComponent.Serializer.fromJson(p_230337_2_.getString("CustomName"));
       }
