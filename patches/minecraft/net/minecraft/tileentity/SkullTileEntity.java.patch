--- a/net/minecraft/tileentity/SkullTileEntity.java
+++ b/net/minecraft/tileentity/SkullTileEntity.java
@@ -1,16 +_,33 @@
 package net.minecraft.tileentity;
 
+import com.google.common.base.Predicate;
+import com.google.common.cache.CacheBuilder;
+import com.google.common.cache.CacheLoader;
+import com.google.common.cache.LoadingCache;
 import com.google.common.collect.Iterables;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
+import com.mojang.authlib.Agent;
 import com.mojang.authlib.GameProfile;
+import com.mojang.authlib.ProfileLookupCallback;
 import com.mojang.authlib.minecraft.MinecraftSessionService;
 import com.mojang.authlib.properties.Property;
+import java.util.Locale;
 import java.util.UUID;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
 import javax.annotation.Nullable;
 import net.minecraft.block.BlockState;
 import net.minecraft.block.Blocks;
+import net.minecraft.entity.player.PlayerEntity;
 import net.minecraft.nbt.CompoundNBT;
+import net.minecraft.nbt.ListNBT;
 import net.minecraft.nbt.NBTUtil;
 import net.minecraft.network.play.server.SUpdateTileEntityPacket;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.management.PlayerProfileCache;
 import net.minecraft.util.StringUtils;
 import net.minecraftforge.api.distmarker.Dist;
@@ -22,10 +_,54 @@
    @Nullable
    private static MinecraftSessionService sessionService;
    @Nullable
-   private GameProfile owner;
+   public GameProfile owner;
    private int mouthTickCount;
    private boolean isMovingMouth;
 
+   // Spigot start
+   public static final ExecutorService executor = Executors.newFixedThreadPool(3,
+       new ThreadFactoryBuilder()
+           .setNameFormat("Head Conversion Thread - %1$d")
+           .build()
+   );
+   public static final LoadingCache<String, GameProfile> skinCache = CacheBuilder.newBuilder()
+       .maximumSize( 5000 )
+       .expireAfterAccess( 60, TimeUnit.MINUTES )
+       .build( new CacheLoader<String, GameProfile>()
+       {
+          @Override
+          public GameProfile load(String key) throws Exception
+          {
+             final GameProfile[] profiles = new GameProfile[1];
+             ProfileLookupCallback gameProfileLookup = new ProfileLookupCallback() {
+                @Override
+                public void onProfileLookupSucceeded(GameProfile gp) {
+                   profiles[0] = gp;
+                }
+                @Override
+                public void onProfileLookupFailed(GameProfile gp, Exception excptn) {
+                   profiles[0] = gp;
+                }
+             };
+             MinecraftServer.getServer().getProfileRepository().findProfilesByNames(new String[] { key }, Agent.MINECRAFT, gameProfileLookup);
+             GameProfile profile = profiles[ 0 ];
+             if (profile == null) {
+                UUID uuid = PlayerEntity.createPlayerUUID(new GameProfile(null, key));
+                profile = new GameProfile(uuid, key);
+                gameProfileLookup.onProfileLookupSucceeded(profile);
+             } else
+             {
+                Property property = Iterables.getFirst( profile.getProperties().get( "textures" ), null );
+                if ( property == null )
+                {
+                   profile = SkullTileEntity.sessionService.fillProfileProperties( profile, true );
+                }
+             }
+             return profile;
+          }
+       } );
+   // Spigot end
+
    public SkullTileEntity() {
       super(TileEntityType.SKULL);
    }
@@ -88,8 +_,36 @@
 
    @Nullable
    public SUpdateTileEntityPacket getUpdatePacket() {
-      return new SUpdateTileEntityPacket(this.worldPosition, 4, this.getUpdateTag());
-   }
+      return new SUpdateTileEntityPacket(this.worldPosition, 4, sanitizeTileEntityUUID(this.getUpdateTag())); // Paper
+   }
+
+    // Paper start
+    public static CompoundNBT sanitizeTileEntityUUID(CompoundNBT cmp) {
+       CompoundNBT owner = cmp.getCompound("Owner");
+      if (!owner.isEmpty()) {
+         sanitizeUUID(owner);
+      }
+      return cmp;
+   }
+
+   public static void sanitizeUUID(CompoundNBT owner) {
+      CompoundNBT properties = owner.getCompound("Properties");
+      ListNBT list = null;
+      if (!properties.isEmpty()) {
+         list = properties.getList("textures", 10);
+      }
+
+      if (list != null && !list.isEmpty()) {
+         String textures = ((CompoundNBT)list.get(0)).getString("Value");
+         if (textures != null && textures.length() > 3) {
+            UUID uuid = UUID.nameUUIDFromBytes(textures.getBytes());
+            owner.putUUID("Id", uuid);
+            return;
+         }
+      }
+      owner.putUUID("Id", UUID.randomUUID());
+   }
+   // Paper end
 
    public CompoundNBT getUpdateTag() {
       return this.save(new CompoundNBT());
@@ -101,32 +_,71 @@
    }
 
    private void updateOwnerProfile() {
-      this.owner = updateGameprofile(this.owner);
-      this.setChanged();
+      // Spigot start
+      GameProfile profile = this.owner;
+      updateGameProfile(profile, new Predicate<GameProfile>() {
+         @Override
+         public boolean apply(GameProfile input) {
+            owner = input;
+            setChanged();
+            return false;
+         }
+      }, false);
+      // Spigot end
    }
 
-   @Nullable
-   public static GameProfile updateGameprofile(@Nullable GameProfile p_174884_0_) {
-      if (p_174884_0_ != null && !StringUtils.isNullOrEmpty(p_174884_0_.getName())) {
-         if (p_174884_0_.isComplete() && p_174884_0_.getProperties().containsKey("textures")) {
-            return p_174884_0_;
-         } else if (profileCache != null && sessionService != null) {
-            GameProfile gameprofile = profileCache.get(p_174884_0_.getName());
-            if (gameprofile == null) {
-               return p_174884_0_;
+   // Spigot start - Support async lookups
+   public static Future<GameProfile> updateGameProfile(GameProfile input, final Predicate<GameProfile> callback, boolean sync) {
+      if (input != null && !StringUtils.isNullOrEmpty(input.getName())) {
+         if (input.isComplete() && input.getProperties().containsKey("textures")) {
+            callback.apply(input);
+         } else if (MinecraftServer.getServer() == null) {
+            callback.apply(input);
+         } else {
+            GameProfile profile = skinCache.getIfPresent(input.getName().toLowerCase(Locale.ROOT));
+            if (profile != null && Iterables.getFirst(profile.getProperties().get("textures"), (Object) null) != null) {
+               callback.apply(profile);
+               return Futures.immediateFuture(profile);
             } else {
-               Property property = Iterables.getFirst(gameprofile.getProperties().get("textures"), (Property)null);
-               if (property == null) {
-                  gameprofile = sessionService.fillProfileProperties(gameprofile, true);
+               Callable<GameProfile> callable = new Callable<GameProfile>() {
+                  @Override
+                  public GameProfile call() {
+                     final GameProfile profile = skinCache.getUnchecked(input.getName().toLowerCase(java.util.Locale.ROOT));
+                     MinecraftServer.getServer().processQueue.add(new Runnable() {
+                        @Override
+                        public void run() {
+                           if (profile == null) {
+                              callback.apply(input);
+                           } else {
+                              callback.apply(profile);
+                           }
+                        }
+                     });
+                     return profile;
+                  }
+               };
+               if (sync) {
+                  try {
+                     return Futures.immediateFuture(callable.call());
+                  } catch (Exception ex) {
+                     com.google.common.base.Throwables.throwIfUnchecked(ex);
+                     throw new RuntimeException(ex); // Not possible
+                  }
+               } else {
+                  return executor.submit(callable);
                }
-
-               return gameprofile;
             }
-         } else {
-            return p_174884_0_;
          }
       } else {
-         return p_174884_0_;
+         callback.apply(input);
       }
+      return Futures.immediateFuture(input);
+   }
+   // Spigot end
+
+   @Nullable
+   public static GameProfile updateGameprofile(@Nullable GameProfile p_174884_0_)
+   {
+      return com.google.common.util.concurrent.Futures.getUnchecked(updateGameProfile(p_174884_0_, com.google.common.base.Predicates.alwaysTrue(), true));
    }
 }
